# 패키지 정의
    자바와 같이 파일 최상단에 적음
    자바와 다르게 디렉토리 상관없이 파일을 위치시켜도 됨
    (디렉토리와 패키지를 일치시키지 않아도 됨)

# 함수 정의
    함수는 fun 키워드로 정의
    문법 
        fun 키워드 + 함수명 + (인자) + :리턴타입 { return }

    fun sum(a: Int, b: Int): Int {
        return a + b
    }

    함수 몸체가 식인 경우 return 생략 가능, return type은 추론됨
    따라서 위 식은 다음과 같이 표현할 수도 있음
    fun sum(a: Int, b: Int) = a + b

# 함수 정의
    리턴할 값이 없는 경우 Unit(Object)로 리턴함
    Unit은 Java의 void와 같은 역할
    fun printKotlin(): Unit {
        println("hello Kotlin")
    }
    Unit은 생략 가능
    fun printKotlin() {
        println("hello Kotlin")
    }

# 지역 변수 정의
    val : value. 변하지 않는 읽기전용 변수
        값의 할당이 1회만 가능, Java의 final과 유사
        val a: Int = 1 // 즉시 할당
        val b = 2 // 'Int' type 추론
        val c: Int // 컴파일 오류, 초기화가 필요함
        c = 3 // 컴파일 오류, 읽기전용
    var : variable. Mutable 변수
        var x : Int = 5
        x += 1
        var name = "YYJ"
        => name의 타입 String은 추론으로 생략됨   

# 주석
    Java와 Javascript와 동일함
    // : 한줄 주석
    /* */ : 여러줄 주석, java와 다르게 주석 중첩 가능(주석 안에 주석)

# 문자열 템플릿(String Template)
    String Interpolation (문자열 보간법)
    var a = 1
    val s1 = "a is $a"
    ($를 이용해서 변수에 직접 접근가능)

    $뒤에 중괄호{}로 변수를 정확히 지정할 수 있다
        a = 2
        val s2 = "${s1.replace("is","was")}, but now is $a"

        val name = "Joon"
        println("my name is ${name}I'm 30")
        = println("my name is $name I'm 30")
        => $name 뒤에 띄어쓰지 않으면 뒷 문자까지 변수로 이해하게돼서 오류생성됨
    
    $를 문자로 쓰고 싶은 경우 \ 사용
        println("this is 2\$a")
        => 이렇게 사용하면 $를 변수로 인식하지 않고 문자로 인식하게 됨

# 조건문
    if
        fun maxOf(a: Int, b: Int): Int {
            if(a>b){
                return a
            }else{
                return b
            }
        }

        축약형식으로 많이 사용한다
            fun maxOf(a: Int, b: Int) = if(a>b) a else b

            자바의 경우 삼항연산자를 많이 사용했음
            return (a>b) ? a : b

    when
        Java의 switch case와 비슷해 보이지만 다르다
        (switch case는 정수나 스트링 정도만 지원되지만 코틀린에선 전부 가능)
        
        fun describe(obj: Any): String =
            when (obj) {
                1   -> "One"
                "Hello"    -> "Greeting"
                is Long    -> "Long"
                !is String  -> "Not a string"
                else    -> "Unknown"
            }

        fun checkNum(score : Int) {
            when(score) {
                0 -> println("this is 0")
                1 -> println("this is 1")
                2,3 -> println("this is 2 or 3")
                else -> println("I don't know")
            }

            var b = when(score) { // return 식으로 사용 가능
                1 -> 1 // score가 1이면 1을 return
                2 -> 2
                else -> 3
            }
            
            when(score) {
                in 90..100 -> println("You are genius") // 90~100
                in 10..80 -> println("not bad")
                else -> println("okay")
            }
        }

# nullable
    값이 null일 수 있는 경우 타입에 nullable 마크("?")를 명시해야 함
        fun parseInt(str: String): Int? {
            // 정수가 아닌 경우 null을 리턴
        }
        parseInt 안이 정수가 아닌 경우 null이 나올 수 있음 => ? 를 붙임으로써 null이 나올 수 있다는 것을 미리 알려준다.
        만약 ? 를 붙이지 않으면 컴파일 오류 발생함

    nullable 타입의 변수에 접근할 때는 반드시 null체크를 해야 함
        fun printProduct(arg1: String, arg2: String){
            val x: Int? = parseInt(arg1)
            val y: Int? = parseInt(arg2)

            if(x != null && y!= null){
                println(x*y)
            }else{
                println("either '$arg1' or '$arg2' is not a number")
            }
        }
        x와 y가 null일 수 있기 때문에 if로 체크한 뒤 x와 y에 접근한다. 만약 체크하지 않고 접근시 x나 y가 null이면 컴파일 오류가 발생하게 된다.

# 자동 타입 변환
    fun getStringLength(obj: Any): Int? {
        if (obj is String){
            // 'obj'가 자동으로 String 타입으로 변환됨
            return obj.length
        }
        return null
    }

    Any = Java의 Object 개념. 최상위 클래스
    위 식은 string 객체가 들어오는 경우에만 객체의 길이(length)를 반환한다.

# For 와 While
    fun forAndWhile(){
        val students = arrayListOf("joyce","james","jenny","jennifer")

        for (name in students){
            println("${name}") //joyce james jenny jennifer
        }
        
        var sum : Int = 0
        for (i in 1..10){
        // for (i in 1..10 step 2){ // 1,3,5,7,9 번째만 순환
        // for (i in 10 downTo 1){ // 10부터 1까지 순환
        // for (i in 1 until 100){ // 1부터 99까지 순환
            sum += i // 55
        }
        println(sum)

        var index = 0
        while(index < 10){
            println("current index : ${index}") // 0 1 2 3 4 5 6 7 8 9
            index++
        }

        for((index,name) in students.withIndex()){
            println("${index+1}번째 학생 : ${name}") // 1번째 학생 : joyce ~ 4번째 학생 : jennifer
        }
        <!-- 
            생각할 점
                while에서 index를 하나씩 늘려서 10까지 만들고 난 뒤 for문으로 넘어온다.
                이 때, for문의 index는 위에서 var로 정의한 index가 아니라 students에 존재하는 index의 길이만큼 순환하게 된다.
                즉, for문의 index는 var index의 영향을 받지 않으므로 index 정의 없이 사용 가능하다.
        -->
    }

# while loop
    Java와 같음

    val items = listOf("apple", "banana", "kiwi")
    var index = 0
    while (index < items.size){
        println("item at $index is ${items[index]}")
        index++
    }

    결과
        item at 0 is apple
        item at 1 is banana
        item at 2 is kiwi
    
# ranges
    In 연산자를 이용해서 숫자 범위를 체크 가능
        val x = 3
        if (x in 1..10){ // x가 1에서 10 사이에 있다면
            println("fits in range")
        }
    
    range를 이용한 for loop
        for (x in 1..5){ // 1부터 5까지의 x에 대하여
            print(x) // 1 2 3 4 5
        }

# Array와 List
    List 종류
        1. List(수정 불가능) 
        2. Mutable List(수정 가능)
    
    fun array(){
        val array = arrayOf(1,2,3) //array 초기화
        val list = listOf(1,2,3) //list 초기화

        val array2 = arrayOf(1,"d",3.4f) //Any 타입으로 추론됨
        val list2 = listOf(1,"d",11L) //Any 타입으로 추론됨

        array[0] = 3 //array는 기본적으로 mutable(수정 가능)
        list[0] = 2 //오류. list는 기본적으로 수정 불가능
        var result = list.get(0) //값을 가져오는 것만 가능
        
        val arrayList = arrayListOf<Int>() // Mutable List
        arrayList.add(10)
        arrayList.add(20)

        arrayList = arrayListOf() //오류. 위에서 val로 정의했기 때문
        // => val로 정의한 arrayList에 add는 가능하지만 새로 정의하는 건 불가능하다
    }


# collections
    컬렉션도 in으로 loop 가능
        val items = listOf("apple", "banana", "kiwi")
        for(item in items){
            println(item)
        }

        listOf로 list를 생성하고 for문과 in을 사용하여 출력함
    
    In으로 해당 값이 collection에 포함되는지 체크 가능
        val items = setOf("apple", "banana", "kiwi")
        when{
            "orange" in items -> println("juicy")
            "apple" in items -> println("apple is fine too")
        }

        in으로 컬렉션에 포함된 값을 체크 가능
    
    람다식을 이용해서 컬렉션에 filter, map 등의 연산 가능
        val fruits = listOf("banana", "avocado", "apple", "kiwi")
        fruits
            .filter{ it.startsWith("a") } // a로 시작하는 것들만 필터링
            .sortedBy{ it } // it로 sorting
            .map{ it.uppercase() } // 대문자로 변경
            .forEach { println(it) } // 각각을 출력하라

        결과
            APPLE
            AVOCADO

        it은 list의 값들이 들어가는 변수

# 기본 타입
    코틀린에서 모든 것은 객체이다 <---> 자바는 primitive(기본형)와 reference 타입이 나눠져 있음
        자바의 Primitive(기본형) type
            기본값이 있기 때문에 Null이 존재하지 않음
            담을 수 있는 크기를 벗어나면 컴파일 에러 발생
            논리형(boolean), 정수형(byte, short, int, long), 실수형(float, double), 문자형(char)

        자바의 Reference(참조형) type
            기본형 타입을 제외한 타입들 모두를 지칭
            빈 객체를 의미하는 Null이 존재함
            배열(Array), 열거(Enumeration), 클래스(Class), 인터페이스(Interface)

    숫자(Number)
        kotlin에서 Number는 클래스이다(대문자로 사용함 Double, Float 등)
        Java에서 숫자형이던 char(Bit width : 16)가 kotlin에서는 숫자형이 아님
    
    리터럴(Literal)
        * Java에서 지원되던 8진수는 미지원 (Java: int I = 017; 앞이 0으로 시작하면 8진수로 해석되었음)
        10진수 : 123 (Int, Short)
        Long : 123L
        Double : 123.5 또는 123.5e10
        Float : 123.5f
        2진수 : 0b00001011 (0b로 시작)
        16진수 : 0X0F (0X로 시작)

        Underscores in numeric literals (코틀린 1.1 버전이후)
            긴 숫자의 경우 underscore(_)를 사용해서 구분하는 것도 언어에서 지원함
            val oneMillion = 1_000_000
            val creditCardNumber = 1234_5678_9012_3456L
            val socialSecurityNumber = 999_99_9999L
            val hexBytes = 0xFF_EC_DE_5E
            val bytes = 0b11010010_01101001_10010100_10010010

    Representation
        Kotlin 숫자형을 Java 플랫폼에서 사용하는 경우 JVM primitive type 또는 박싱이 돼서 object로 처리된다 (Nullable이나 제네릭의 경우에 박싱됨)
        박싱된 경우엔 identity를 유지하지 않는다
        
        // JVM primitive
        val a: Int = 100
        print(a === a) // true

        // Boxed
        val boxedA: Int? = a
        val anotherBoxedA: Int? = a
        println("==: ${boxedA == anotherBoxedA}") // true
        println("===: ${boxedA === anotherBoxedA}") // true

        tools > Kotlin > Show Kotlin Bytecode > 알아보고 싶은 것을 클릭하고 Decompile
        (코틀린을 컴파일하면 바이트코드가 됨. 이것을 Decompile 하면 자바코드를 얻을 수 있다.)
```kotlin
    fun main() {
        var a: Int = 100000
        var b: Int = 100000
        println("a === b: ${a === b}") // 같은 객체인지, true
        println("a == b: ${a == b}") // 값이 같은지, true

        /* decompile을 해보면 var a와 var b가 int a와 int b로 표시된다. (primitive 타입)
        처음에 var로 선언할 때 클래스(Int)로 선언했지만, 코틀린에서 JVM으로 돌아갈 땐 둘다 primitive 타입으로 사용되었다. */

        var c: Int? = 100000
        println("a === c: ${a === c}") // true
        println("a == c: ${a == c}") // true

        /* decompile 후 var c 는 Integer c 로 표시된다 (object 타입) */

        /* 강의에선 변수 c가 Nullable한 경우 object 타입으로 읽히고
        변수 a는 primitive 타입으로 읽혀서 === 으로 비교시 객체가 다르기 때문에 false를 반환한다고 나오는데.. 
        난 true가 나온다.. 왜지? */
    }
```
        어쨋든 Kotlin에서 숫자를 사용할 때 암묵적인 형변환을 지원하지 않는다 (더 작은 자료형은 더 큰 자료형에 서브 자료형이 아니다!)
        다시 정리하면, JVM 플랫폼에서 숫자는 int, double과 같은 primitive type으로 저장되고 nullable과 제네릭은 java class로 저장되므로 만약 암묵적 형변환이 있으면 객체 자체가 변화되는 일이 발생하고 equality와 identity 검사가 의미를 잃게 된다.
        따라서 kotlin에서는 암묵적 형변환은 지원되지 않고 명시적 형변환을 해줘야 한다.

        toInt() => .code
        toByte() => .code.toByte()
        toShort() => .code.toShort()
        toLong() => .code.toLong()
        toFloat() => .code.toFloat()
        toDouble() => .code.toDouble()
        toChar() 또는 .code.toChar()
        를 사용해서 형변환 함

        Explicit Conversions
            val a: Int = 1
            val b: Long = a // 오류 => Int를 Long으로 만들어주기 위해 형변환 필요
            val b: Long = a.toLong()
            
            println(a == b) // Int와 Long을 비교할 수 없기 때문에 오류 발생

            val i: Int = b.toInt()
            println(a == i) // true

    문자 (Characters)
        Char는 숫자로 취급되지 않음    
        
        fun check(c: Char){
            if(c == 1){ } // Char와 Int를 비교하기 때문에 컴파일 에러
        }

        fun check2(c: Char){
            if(c == 'a'){ } // 같은 문자형이기 때문에 컴파일 가능
        }

        fun main() {
            print('0'.code) // 문자 0을 숫자로 변환, 유니코드 값 48
        }
    
    문자열
        String 클래스로 표현
        String은 characters로 구성됨
        s[i]와 같은 방식으로 접근 가능 (immutable이므로 변경 불가)
        
        var x: String = "Kotlin"
        println(x.get(0)) // K
        println(x[0]) // K
        println(x.length) // 6

        for (c in x){
            println(c) // Kotlin
        }

        문자열 리터럴
            escaped string ("Kotlin")
                전통적인 방식으로 Java String과 거의 비슷
                Backslash(\)를 사용하여 escaping 처리
            
            raw string ("""kotlin""")
                큰따옴표 3개를 이용
                escaping 처리 필요 없음
                개행이나 어떠한 문자 포함 가능
            
            val s = "Hello, world!\n"
            val ss = """
            "'이것은 코틀린의
            raw String
            입니다.'"
            """

    배열
        Java와 생성 방법은 다르지만 사용방법은 비슷하다

        배열은 Array 클래스로 표현됨
        클래스 안에 get ,set 메소드 존재 
            []로 연산자 오버로딩해서 값에 접근함
        size 등 유용한 멤버함수 포함

        var array: Array<String> = arrayOf("코틀린", "강좌")
        println(array.get(0)) // 코틀린
        println(array[0]) // 코틀린
        println(array.size) // 2

        배열 생성
            Array의 팩토리 함수 이용
                val b = Array(5, { i => i.toString() })
                : i를 0부터 4까지 5개를 리턴하여 Array 생성

                fun main() {
                    val a = Array(5, { i -> i.toString() })
                    for (c in a) {
                        print(c) // 01234
                    }
                }
                
            arrayOf() 등의 라이브러리 함수 이용
                val a = arrayOf("0", "1", "2", "3", "4")

                fun main() {
                    val b = arrayOf("0", "1", "2", "3", "4", "5")
                    for (c in b) {
                        print(c) // 01234
                    }
                }

        특별한 Array 클래스
            Primitive 타입의 박싱 오버헤드를 없애기 위한 배열
                var array: Array<String> = arrayOf("코틀린", "강좌")
                에서 처럼 Array에 <String>을 붙이면 제네릭이 사용되고, 이 경우 primitive 타입이 아니라 reference 타입으로 동작하게 됨. 
                이런 것을 해결하기 위한 배열 => IntArray, ShortArray, IntArray 
            Array를 상속한 클래스들은 아니지만, Array와 같은 메소드와 프로퍼티를 가짐
            
            val x: IntArray = intArrayOf(1, 2, 3)
            x[0] = 7
            println(x.get(0)) // 7
            println(x[0]) // 7
            println(x.size) // 3
    
# Control Flow (흐름제어)
    If else 문
        Java와 유사함

        // Traditional usage
        var max = a
        if (a < b) max = b

        var max: Int
        if (a > b) {
            max = a
        } else {
            max = b
        }

        If 문이 식으로 사용되는 경우 (Java에 없음)
            val max = if (a > b) a else b
            If 식의 경우 반드시 else를 동반해야 한다
        
            If식의 branch들(If나 else)이 블럭({...})을 가질 수 있음
            블럭의 마지막 값이 해당 식의 값을 대표함
            val max = if (a > b){
                print("Choose a")
                a // if가 참일때 if 블럭에 있는 이 a 값이 max로 들어가게 됨
            } else {
                print("Choose b")
                b
            }
    
        삼항연산자(ternary)가 없다 (Java에 있지만 Kotlin엔 없음)
            코틀린에서 if문이 삼항연산자 역할을 잘 해낸다

            Java
            int max = (a > b) ? a : b; // 조건문이 참이면 a 거짓이면 b
            
            Kotlin
            val max = if(a > b) a else b
    
    when
        when문은 C열 언어의 switch문을 대체한다
        when문은 각각의 branches의 조건문이 만족할 때까지 위에서부터 순차적으로 인자를 비교한다        
            when (x) {
                1 -> print("x == 1")
                2 -> print("x == 2")
                else -> {
                    print("x is neither 1 nor 2")
                }
            }
            => 인자 x와 화살표 앞의 조건을 비교해서 해당되는 브랜치만 실행됨

            var res = when (x) {
                100 -> "A"
                90 -> "B"
                80 -> "C"
                else -> "F"
            }

        when이 식으로 사용된 경우 else문이 필수이다
        (컴파일러가 else문이 없어도 된다는 것을 입증할 수 있는 경우에는 else를 생략가능)
            var res = when (x) {
                true -> "맞다"
                false -> "틀리다"
            }
            => x에 boolean 으로 true/false 2가지만 오게 되는 경우에 else를 생략했다

        조건이 여러개라면 branch의 조건문에 콤마(,)를 사용한다
            when (x) {
                0, 1 -> print("x == 0 or x == 1")
                else -> print("otherwise")
            }
        
        branch의 조건문에 함수나 식을 사용할 수 있다
            when (x) {
                parseInt(x) -> print("s encodes x")
                1 + 3 -> print("4")
                else -> print("s does not encodes x")
            }

        range나 collection에 in이나 !in으로 범위 등을 검사할 수 있다
            val validNumbers = listOf(3, 6, 9)
            when (x) {
                in validNumbers -> print("x is valid") // x가 3, 6, 9 중에 있으면 프린트
                in 1..10 -> print("x is in the range") // 1부터 10 사이에 있으면 프린트
                !in 10..20 -> print("x is outside the range")
                else -> print("none of the above")
            }

        Is나 !is를 이용하여 타입을 검사할 수 있다
        이때 스마트 캐스트가 적용된다
        (스마트 캐스트 : 아래에서 x는 Any라고 선언했지만 Any에는 .startsWith() 가 없다. 하지만 앞에 x가 String일 경우라는 조건을 달아줬기 때문에 x를 String이라고 생각해서 해당 함수를 사용할 수 있게 되는 것)
            fun hasPrefix(x: Any) = when(x) {
                is String -> x.startsWith("prefix")
                else -> false
            }
            => x가 String이면 x.startsWith("prefix") 를 반환, 아니면 false 반환
            => Kotlin에서 타입 검사를 한 구문 뒤에서는 스마트캐스트가 적용된다

        if-else if 문을 대체할 수 있다
        when에 인자를 입력하지 않으면 조건문들이 논리연산됨
            when {
                x.isOdd() -> print("x is odd")
                x.isEven() -> print("x is even")
                else -> print("x is funny")
            }
            => if-else if로 길었던 구문을 when으로 한번에 처리할 수 있다!
    
    For Loops
        for문은 iterator를 제공하는 모든 것을 반복할 수 있다
            for (item in collection)
                print(item)
            => collection의 항목들이 item에 하나씩 들어오면서 프린트됨(foreach와 비슷)

            fun test(){
                var collection = listOf(1, 2, 3, 4, 5)
                for (item in collection) print(item) // 12345

                // iterator()와 while 사용
                var collectionIterator = collection.iterator()
                while (collectionIterator.hasNext()) {
                    print(collectionIterator.next()) // 12345
                }

                var array = arrayOf(1, 2, 3, 4, 5)
                for (i in array){
                    println("$i: $array[i]")
                }
            }
            => listOf와 arrayOf가 iterator를 반환하기 때문에 for문으로 사용할 수 있음
        
        for문의 body가 블럭이 올 수도 있음
        for (item in collection){
            print(item.id)
            print(item.name)
        }

        For문을 지원하는 iterator의 조건
            1) 멤버함수나 확장함수 중에 
                iterator()를 반환하고, next()를 가지고, hasNext(): Boolean을 가지는 경우
            2) 위 세 함수는 operator로 표기되어야 함

            fun main (args: Array<String>){
                val myData = MyData()
                for (item in myData){
                    print(item)
                }
            }
            // => MyData는 list나 array가 아닌데 for문안에 들어갔음 : myData가 iterator()를 반환하기 때문
            
            class MyData{
                operator fun iterator(): MyIterator{
                    return MyIterator()
                }
            }
            // => MyData 클래스에 operator 로 함수를 만들어서 Myiterator를 반환시켜줌

            class MyIterator{
                val data = listOf(1, 2, 3, 4, 5)
                var idx = 0
                operator fun hasNext(): Boolean {
                    return data.size > idx // idx가 5가 되면서 false를 리턴하면 종료된다
                }

                operator fun next(): Int {
                    return data[idx++]
                }
            }
            // => MyData에서 반환된 MyIterator는 list이고 operator로 된 hasNext()와 next()를 가진다
        => operator가 하나라도 빠지면 오류 발생
        => 어떤 객체가 iterator를 반환하면 next()와 hasNext(): Boolean를 구현하여 for문을 사용할 수 있다.

        배열이나 리스트에서 index를 이용하고 싶은 경우 indices 이용
            val array = arrayOf("가", "나", "다")
            for(i in array.indices){
                println("$i: ${array[i]}") // 0: 가 1: 나 2: 다
            }
        
        withIndex()로도 index 사용 가능
            val array = arrayOf("가", "나", "다")
            for ((index, value) in array.withIndex()){
                println("$index: ${value}") // 위와 같음
            }

    While Loops
        while, do-while문은 Java와 거의 같다
        Java와 다른점) do-while문에서 body의 지역변수를 do-while문의 조건문이 참조할 수 있음
            do {
                val y = retrieveData()
            } while (y != null)
            => Java의 경우 do 이전에 y를 선언하고 do와 while에서 각각 사용해야 했는데,
            코틀린은 do 안(do-while문의 body)에 y를 선언하고 while에서 사용할 수 있다.

# 패키지
    소스파일은 패키지 선언으로 시작됨
    모든 컨텐츠(클래스, 함수 등)는 패키지에 포함됨
    패키지를 명세하지 않으면 이름이 없는 기본 패키지에 포함됨

    Test.kt 파일에서 Other.kt와 Other2.kt 에 있는 두 함수를 불러오려고 함

    <Other.kt>
    // Other는 패키지를 적지 않아서 기본 패키지에 포함됨
    fun printOther1(){
        println("Other_1")
    }

    <Other2.kt>
    package test.pkg // Other2는 test.pkg에 있음을 표시함
    fun printOther2(){
        println("Other_2")
    }
    
    <Test.kt>
    import test.pkg.printOther2 
    // printOther2를 사용하기 위해 패키지 import함
    // import는 해당 함수를 클릭하고 Alt + 엔터
    fun main (){
        printOther1()
        printOther2()
    }

    => 명세한 패키지의 함수를 사용하기 위해선 import를 해야하고, 패키지를 명세하지 않았을 경우 그냥 함수를 바로 사용할 수 있다.

# 기본 패키지
    기본으로 import되는 패키지가 있음
    플랫폼 별로 import되는 패키지가 다르다

    kotlin.*
    kotlin.annotation.*
    kotlin.collections.*
    kotlin.comparisons.*
    kotlin.io.*
    kotlin.ranges.*
    kotlin.sequences.*
    kotlin.text.*

    JVM 추가 기본 패키지
        java.lang.*
        kotlin.jvm.*
    
    JS 추가 기본 패키지
        kotlin.js.*

    fun main(args: Array<String>) {
        var a = listOf(1, 2, 3)
        println(a)
    }
    => listOf() 함수는 Collections.kt 파일 안에 있고 해당 파일은 kotlin.collections 패키지에 포함되어 있기 때문에 import 없이 사용 가능하다

# Imports
    한개의 요소만 import
    import foo.Bar

    foo 패키지의 모든것을 import
    import foo.*

    같은 이름의 요소가 충돌되는 경우 as로 로컬 리네임 가능
    위에서 foo.Bar와 별개로 bar패키지의 Bar를 import하고 싶은 경우
    import bar.Bar as bBar

# Jump 표현식
    return, break, continue
    
    일반적으로 Java와 사용방법이 같음
        fun sum(a: Int, b: Int): Int{
            println("a: $a, b: $b")
            return a + b
        }

        for (x in 1..10) {
            if (x > 2){
                break
            }
            println("x: $x")
        }

        for (x in 1..10) {
            if (x < 3){
                continue
            }
            println("x: $x") // x: 3 ... x: 10
        }

    * 예외) Label로 Break, Continue, Return 사용

# Label
    Break and Continue 
        레이블 표현 : label@, abc@, fooBar@
        (식별자 + @ 형태로 사용)

        loop@ for (i in 1..10) {
            println("--- i: $i ---")
            for (j in 1..10) {
                println("j: $j")
                if (i + j > 12){
                    break@loop
                }
            }
        }
        => for문 아래에서의 break는 해당 for문만 종료시킨다
        따라서 for문이 2개인 경우 둘다 종료시키기 위해서는 break를 2개 써야한다
        하지만 첫 for문을 loop@ 로 시작하고 다시 break@loop를 걸어주면 두 개의 for문을 한번에 종료시킬 수 있다

        loop@ for (i in 1..10) {
            println("--- i: $i ---")
            for (j in 1..10) {
                if (j < 2){
                    continue@loop
                }
                println("j: $j")
            }
        }
        => label이 j<2 일때 작동하므로 계속 첫 for문으로 돌려보낸다
        따라서 --- i: 1 --- 부터 --- i: 10 --- 까지 전부 출력됨

    Return
        코틀린에서 중첩될 수 있는 요소들
            함수 리터럴(function literals)
            지역함수(local function)
            객체 표현식(object expression)
            함수(function)

        1. fun foo(){
            var ints = listOf(0, 1, 2, 3)
            ints.forEach(fun(value:Int){
                if (value == 1) return // 1인 경우에 아래 프린트 함수 사용X
                print(value)
            })
            print("End")
        }
        => forEach 안에 익명함수를 넣어서 사용함
            1일때 forEach에서 해당함수만 종료시킴(0, 2, 3에선 실행됨)
        => 출력 : 023End

        2. fun foo2(){
            var ints = listOf(0, 1, 2, 3)
            ints.forEach(
                {
                    print(it)
                }
            )
            print("End")
        }
        => 01234End

        3. fun foo2(){
            var ints = listOf(0, 1, 2, 3)
            ints.forEach(
                { // 람다식(익명함수) 시작
                    if (it == 1) return
                    print(it)
                }
            )
            print("End")
        }
        => 0
        => 1번과 결과가 다른 이유 : 람다식 안에서 return을 하면 가장 가까운 함수가 종료된다
        => 람다식만 종료시키고 싶을 경우, label로 return을 사용!

        4. fun foo3(){
            var ints = listOf(0, 1, 2, 3)
            ints.forEach label@ {
                if (it == 1) return@label
                print(it)
            }
            print("End")
        }
        => 023End
        => 람다식에 return을 사용하여 it가 1인 람다식만 종료시키고, 나머지 람다식은 그대로 실행

    * 암시적 레이블
        특정 람다식에 대해서만 return하는 경우 label을 이용해서 return 해야하기 때문에 번거로운 부분이 있다
        직접 label을 사용하는 것보다 암시적 레이블이 편리함
        암시적 레이블은 람다가 사용된 함수의 이름과 동일함

        fun foo4(){
            var ints = listOf(0, 1, 2, 3)
            ints.forEach {
                if (it == 1) return@forEach
                print(it)
            }
            print("End")
        }
        => 람다가 사용된 함수의 이름 = forEach
        => 023End

    * 레이블 return시 값을 반환할 경우
        return + @label + 값
        
        fun foo5(){
            var ints = listOf(0, 1, 2, 3)
            val result = ints.map {
                if (it == 0){
                    return@map "빵" // it가 0인 경우 빵 리턴
                }
                // else{} 생략
                "number $it" // it가 0이 아닌 경우 number + 숫자 리턴
            }
            print(result)
        }

# Class
    클래스는 class 키워드로 선언함
    class + 클래스 이름 + (클래스 헤더) + {클래스 바디}
        클래스 헤더는 매개변수와 기본생성자(+어노테이션, 접근지정자)
    class Invoice(data: Int)

    헤더와 바디는 옵션이다
        class Empty

    * 기본 생성자
        클래스별로 1개만 가질 수 있음
        클래스 헤더의 일부분
        클래스 이름 뒤에 작성함
        class Person constructor(firstName: String) { }

        어노테이션이나 접근 지정자가 없을 때에는 기본생성자의 constructor 키워드를 생략 가능
        class Person constructor(firstName: String) { }
        = class Person(firstName: String) { }

        기본생성자는 코드를 가질 수 없음
            초기화는 초기화(init) 블럭 안에서 작성해야 함
            초기화 블럭은 init 키워드로 작성
        기본생성자의 파라미터는 init 블럭 안에서 사용 가능함
            class Customer(name: String) {
                init{
                    logger.info("Customer initialized with value ${name}") // 기본 생성자의 코드
                }
            }
            => Customer 클래스의 기본생성자(name)의 코드는 init 블럭 안에 들어감

            fun main (){
                val obj = Customer("코틀린")
            }

            class Customer public constructor(name: String) {
                //println("이름: $name")
                // 클래스의 바디 부분은 클래스의 구성요소들이 들어와야 하기 때문에 사용 불가

                fun print() {
                    //println("이름: $name")
                    // 여기서도 사용 불가
                }

                init {
                    println("이름: $name")
                    // init에서 기본 생성자를 사용함
                }
            }
        
        기본생성자의 파라미터는 프로퍼티 초기화 선언에도 사용가능
            class Customer(name: String){
                val customerKey = name.toUpperCase()
            }
            기본생성자의 매개변수로 넘어 온 값을 프로퍼티(customerKey)의 초기값으로 사용할 수 있다
        
        프로퍼티 선언 및 초기화는 기본생성자에서 간결한 구문으로 사용가능
            클래스의 파라미터 자리에 프로퍼티를 넣어서 사용 가능하다
            class Person(val firstName: String, val lastName: String) {
                
            }
```kotlin
    fun main (){
        val obj = Customer()
        obj.fullname = "코틀린"
        println(obj.fullname) // 코틀린
    }

    class Customer () {
        var fullname: String = ""
            // get() {return field}
            // set(value) {field = value}
    }
    => 프로퍼티 : fullname 이름 아래에 get set을 두고 사용할 수 있게 만든 것

    프로퍼티를 만들지 않고 기본생성자의 헤더에 넣어서 쓸 수도 있음
    fun main (){
        val obj = Customer("코틀린")
        println(obj.fullname) // 코틀린
    }

    class Customer (var fullname: String) {
        val customerKey = fullname.uppercase(Locale.getDefault())
    }
```
        기본생성자에 어노테이션 접근지정자 등이 있는 경우 constructor 키워드 필요
            class Customer public @Inject constructor(name: String){ }
        
    보조생성자
        클래스별로 여러개를 가질 수 있음
        클래스의 바디에 선언 함(<-> 기본생성자는 클래스의 헤더에 선언)
        constructor 키워드로 선언
        class Person{
            constructor(parent: Person){
                parent.children.add(this)
            }
        }

        클래스가 기본생성자를 가지고 있다면, 각각의 보조생성자들은 기본생성자를 직/간접적으로 위임해줘야 함
        this 키워드를 이용함
            직접적 : 기본생성자에 위임
            간접적 : 다른 보조생성자에 위임

            class Person(val name: String){
                => 기본생성자는 String을 받는 name

                constructor(name: String, parent: Person) : this(name){ }
                => name과 parent를 가진 보조생성자에서 this를 이용해서 기본생성자를 부름(직접적)

                constructor() : this("홍길동", Person()){ }
                => 기본생성자를 직접적으로 호출하지 않고 바로 위에 있는 보조생성자를 호출하고 그곳의 this를 통해서 기본생성자와 연결됨(간접적)
            }
    
    생성된(generated) 기본생성자
        클래스에 기본생성자나 보조생성자를 선언하지 않으면 생성된 기본생성자가 만들어짐
        generated primary constructor 특징
            매개변수가 없음
            가시성이 public임
        만약 생성된 기본생성자의 가시성이 public이 아니어야 한다면, 다른 가시성을 가지는 빈 기본생성자를 선언해야 함

        class DontCreateMe private constructor() { }

    인스턴스 생성
        코틀린은 new 키워드가 없다
        객체를 생성하려면 생정자를 일반 함수처럼 호출하면 된다

        val invocie = Invoice()
        val customer = Customer("Joe Smith")
    
    클래스 멤버(바디에 올 수 있는 것들)
        Constructors(생성자 중 보조생성자)
        Initializer blocks(기본생성자에서 호출)
        Functions(함수)
        Properties(프로퍼티)
        Nested and Inner Classes(중첩이나 클래스 안의 클래스)
        Object Declarations(오브젝트 선언)

# Inheritance(상속)
    상속
        코틀린의 최상위 클래스는 Any
        클래스에 상위타입을 선언하지 않으면 Any가 상속됨
        
        class Example1 // 암시적으로 Any 상속됨
        class Example2 : Any() // 명시적으로 Any 상속

        Any는 Java.lang.Object와는 다른 클래스이다(object와 다르다)
            Any에는 equals(), hashCode(), toString() 만 있음

            package kotlin
            public open class Any{
                public open operator fun equals(other: Any?): Boolean
                public open fun hashCode(): Int
                public open fun toString(): String
            }

        명시적으로 상위타입을 선언하려면, 클래스헤더의 콜론 뒤에 상위타입을 선언한다
        
            open class Base(p: Int) // 상속을 해줄 클래스에 open을 붙임
            class Derived(p: Int) : Base(p) // 상속받을 클래스의 헤더 뒤에 :을 찍고 상위타입을 선언함
        
        파생클래스에 기본생성자가 있으면, 기본생성자에서 상위타입의 생성자를 호출해서 초기화할 수 있다
            open class AA(x: Int) { }
            class BB(x: Int) : AA(x) { }

        파생클래스에 기본생성자가 없으면
        1. 각각의 보조생성자에서 상위타입을 super 키워드를 이용해서 초기화해주거나
        2. 다른 생성자에게 상위타입을 초기화할 수 있게 위임해줘야 한다

            class MyView : View{
                constructor() : super(1) // 매개변수가 없는 상황. super라는 키워드를 이용해서 View에 있는 기본생성자를 초기화함
                constructor(ctx: Int) : this() // 매개변수가 하나 있는 보조생성자. this()를 이용해서 바로 위에 있는 constructor()를 이용해서 상위타입을 초기화 함
                constructor(ctx: Int, attrs: Int) : super(ctx, attrs) // super 키워드로 초기화
            }
            => MyView에 primary constructor가 없고, secondary constructor 3개를 만든 상태
            primary constructor에서 super 타입의 초기화가 되지 않았기 때문에 각각의 보조생성자에서 super 타입을 각각 불러와야 하는 상황임

        open 어노테이션은 Java의 final과 반대
        open class는 다른 클래스가 상속할 수 있음
        기본적으로 코틀린의 모든 class는 final임(상속 X)

# 메소드 오버라이딩
    오버라이딩 될 메소드 : open 어노테이션 필요
    오버라이딩 된 메소드 : override 어노테이션 필요
        open class Base {
            open fun v() { }
            fun nv() { }
        }
        class Derived() : Base() {
            override fun v() { }
        }
        => Base클래스의 v 함수를 open으로 선언하고 Derived 클래스에서 override로 상속받음

# 프로퍼티 오버라이딩
    메소드 오버라이딩과 유사한 방식으로 오버라이딩 가능
        open class Foo {
            open val x: Int get { ... }
        }
        class Bar1 : Foo() {
            override val x: Int = ...
        }
    
# 오버라이딩 규칙
    같은 멤버에 대한 중복된 구현을 상속받은 경우, 상속받은 클래스는 해당 멤버를 오버라이딩하고 자체 구현을 제공해야 함
    super + <클래스명> 을 통해서 상위 클래스를 호출할 수 있음
        open class A{
            open fun f() {print("A")}
            fun a() {print("a")}
        }

        interface B {
            fun f() {print("B")}
            fun b() {print("b")}
        }

        class C() : A(), B {
            override fun f() {
                super<A>.f() // call to A.f()
                super<B>.f() // call to B.f()
            }
        }
        => class C 에서 interface인 B를 implements 하고, class인 A를 extends 함
        (클래스는 1개, 인터페이스는 여러개 상속 가능 = Java와 같음)

        문제) 인터페이스 B에 f라는 함수와 클래스 A의 f 함수가 충돌됨
        => C에서 직접 f라는 구현체를 제공해서 모호성을 풀수 있도록 코틀린에서 지원함

# 추상 클래스
    abstract 멤버는 구현이 없음
    abstract 클래스나 멤버는 open이 필요없음(interface에서도 동일)
        abstract class AbsClass{
            abstract fun f()
        }

        class MyClass() : AbsClass() {
            override fun f() { }
        }

# 프로퍼티 선언
    코틀린 클래스는 프로퍼티를 가질 수 있다 (Java는 프로퍼티가 없음)
    var (mutable), val (read-only)
        class Address {
            var name: String = "Kotlin"
            var city: String = "Seoul"
        }

    프로퍼티 사용은 자바의 필드를 사용하듯이 하면 됨
        fun copyAddress(address: Address): Address {
            val result = Address()
            result.name = address.name
            // ...
            return result
        }

    프로퍼티 문법
        전체문법
            var <propertyName>[:<PropertyType>][=<property_initializer>]
                [<getter>]
                [<setter>]

        옵션(생략가능)
            PropertyType
                property_initializer에서 타입을 추론 가능한 경우 생략가능
            property_initializer
            getter
            setter
        
        fun main (args: Array<String>){
            var obj = Address()
            println(obj.name) // Kotlin
        }
        class Address {
            val name: String = "Kotlin"
        }
        => 위 코드를 실행하면 main에서 Address에 접근해서 name 프로퍼티의 값 Kotlin이 출력된다
        Tools > Kotlin > Show Kotlin Bytecode > Decompile 로 Java 코드로 바꿔서 보면,
        1. Address 클래스의 name 변수 아래에 getName() 이라는 메소드가 생겨서 name을 반환해주고
        2. main 함수 아래에 getName()으로 name을 받아온다

        프로퍼티는 Java의 필드변수를 사용하는 것처럼 쉽게 사용할 수 있다. 하지만 변수가 아니고 getter와 setter같은 "함수"적인 요소가 숨어있다. 
        (C#, JS, Python, Ruby, Kotlin 같은 언어는 프로퍼티를 언어 레벨에서 지원한다)

        위 Address 프로퍼티를 다음과 같이 getter, setter 함수랑 같이 표현해줄 수 있다
            class Address {
                var name: String = "Kotlin"
                    get() {
                        return field + "!!!"
                    }
                    set(value) { field = value }
            }
            => main에서 Kotlin!!! 으로 출력됨

    var (mutable) 프로퍼티
        class Address {
            var initialized = 1
            // dafault getter와 setter 있음
            // 타입은 Int
            
            var allByDefault: Int? // 이런 경우 초기화해주지 않아서 error 발생
            // default getter, setter를 사용한 경우 명시적인 초기화가 필요하다
        }

    val (read-only) 프로퍼티
        var대신 val 키워드 사용
        setter가 없음

        class Address {
            val initialized = 1
            // default getter

            var allByDefault: Int? // 오류발생. 명시적인 초기화 필요
        }

    Custom accessors (= getter, setter)
        custom accessor는 프로퍼티 선언 내부에 일반 함수처럼 선언할 수 있음
        
        getter
            val isEmpty: Boolean
                get() = this.size == 0 // this.size가 0이면 true를 반환하는 getter
        
        setter
            관습적으로 setter의 파라미터 이름은 value임 (변경가능)

            var stringRepresentation: String
                get() = this.toString()
                set(value) {
                    setDataFromString(value)
                }

    타입생략
        getter를 통해 타입을 추론할 수 있는 경우, 프로퍼티의 타입을 생략할 수 있음
        
        val isEmpty: Boolean
            get() = this.size == 0
        으로 썼던 것을 다음과 같이 사용해도 됨
        val isEmpty
            get() = this.siez == 0

    프로퍼티
        accessor에 가시성 변경이 필요하거나 어노테이션이 필요한 경우
        기본 accessor의 수정 없이 body없는 accessor를 통해 정의 가능
            var setterVisibility: String = "abc"
                private set
            var setterWithAnnotation: Any? = null
                @Inject set
        Body를 작성해도 됨
            var setterVisibility: String = "abc"
                private set(value) {
                    field = value
                }
        
        => accessor의 어떤 변경없이 가시성만 바꾸거나 어노테이션을 붙일 수 있다

    Backing Fields
        코틀린 클래스는 field를 가질 수 없다
        field 라는 식별자를 통해 접근할 수 있는 automatic backing field를 제공함
        field는 프로퍼티의 accessor에서만 사용 가능하다
            var counter = 0
                set(value) {
                    if(value >= 0) field = value
                }
            => counter라는 프로퍼티의 값을 설정하는 코드
            값이 0보다 클 때만 설정됨
            value가 field에 저장됨
    
        생성조건
            accessor 중 1개라도 기본 구현을 사용하는 경우(재정의 안 하는 경우)
            custom accessor에서 field 식별자를 찹조하는 경우
            
            아래의 경우는 backing field를 생성하지 않음
                val isEmpty: Boolean
                    get() = this.size == 0
                => val이 read-only 여서 set이 존재하지 않는데 get에서 field라는 식별자를 사용하지 않았기 때문
        
    Backing Properties
        "implicit backing field" 방식이 맞지 않는 경우에는 "backing property"를 이용할 수도 있음
        
        private var _table: Map<String, Int>? = null
        public val table: Map<String, Int>
            get(){
                if(_table == null){
                    _table = HashMap()
                }
                return _table ?: throw AssertionError("null")
            }
        => public으로 된 프로퍼티를 하나 만들고 프로터피 내부적으로 동작할 프로퍼티를 추가 생성(여기선 _table)
        처음구동시 _table이 null이기 때문에 HashMap() 객체가 생성됨

    Compile-Time Constants
        const modifier를 이용하면 컴파일 타임 상수를 만들 수 있음
        (이런 프로퍼티는 어노테이션에서도 사용 가능하다)

        조건
            1. Top-level 이거나
            2. object의 멤버이거나
            3. String이나 Primitive 타입으로 초기화된 경우
        
        const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"
        @Deprecated(SUBSYSTEM_DEPRECATED)
        fun foo() { }
        => 어노테이션에 값을 전달할 때 컴파일 타입의 값이어야 함. 이때 const라는 modifier를 써줘야 함
        여기서 String 타입으로 초기화 됐기 때문에 사용 가능

        val MY_CONST = "CONST"
        const val NEW_CONST ="NC"

        @Deprecated(MY_CONST)
        fun main (args: Array<String>){
            var obj = Address()
            println(obj.isEmpty)
        }
        => 이 경우 MY_CONST는 오류가 난다. NEW_CONST처럼 앞에 const를 붙여줘야 사용 가능하다

    Late-Initialized Properties
        일반적으로 프로터피는 non-null 타입으로 선언됨
        간혹 non-null 타입 프로퍼티를 사용하고 싶지만 생성자에서 초기화를 해줄 수 없는 경우가 있음
            1. Dependency injection
            2. Butter knife
            3. Unit test의 setup 메소드
            이 세 경우에 생성자에서 객체를 설정할 수 없기 때문에 각각에서 값이 할당되어야 함
        객체가 constructor에서는 할당되지 못하지만 여전히 non-null 타입으로 사용하고 싶은 경우 Lateinit modifier를 사용 가능

        public class MyTest{
            lateinit var subject: TestSubject

            @SetUp fun setup(){
                subject = TestSubject()
            }

            @Test fun test(){
                subject.method()
            }
        }
        => subject라는 프로퍼티가 있고, 생성자에서 해당 프로퍼티의 값이 할당되는게 아니라 setup()에서 값이 할당됨
        => 즉 setup() 에서 subject라는 프로퍼티가 나중에 초기화 되기 때문에 그걸 알려주기 위해 프로퍼티에 lateinit 키워드를 붙여서 컴파일러에게 알려준다

        조건
            클래스의 바디에서 선언된 프로퍼티만 가능
            기본생성자에서 선언된 프로퍼티는 안 됨
            var 프로퍼티만 가능
            custom accessor가 없어야 함
            non-null 타입이어야 함
            프리미티브 타입이면 안 됨
        lateinit 프로퍼티가 초기화되기 전에 접근되면 오류 발생
```kotlin
fun main (args: Array<String>){
    var obj = Address()
    println(obj.data)
}
//lateinit var data: String 외부(top-level)에서는 사용불가

//class Address (lateinit var data: String){ 기본생성자에서 선언된 프로퍼티도 사용불가
class Address {
    //var data: String
    //lateinit val data: String  read-only인 val의 경우에도 사용불가
    lateinit var data: String//? 키워드로 nullable이면 사용불가
    //lateinit var data: String: Int 이런 primitive 타입이면 사용불가
        //get() {return field} // custom accessor가 있으면 사용불가
//    init{
//        data = "Kotlin" //일반적인 초기화
//    }
    fun setUp(){
        data = "나중에"
    // data의 값을 넣었는데도 init 블럭이 아니어서 초기화가 되지 않아서 오류발생
    // 이럴 때 lateinit 사용
    }
}
```

# Data Classes
    용도 : 데이터는 보유하지만 아무것도 하지 않는 클래스
    코틀린에서 data class 제공함
        data class User(val name: String, val age: Int)
    기본 생성자에서 선언된 속성을 통해, 다음 기능들을 컴파일러가 자동으로 생성해 줌
        equals()
        hashCode()
        copy()
        toString()
            => 위의 name과 age이 "User(name=John, age=42)" 으로 출력됨
        componentN() functions
    개발자가 위 기능을 명시적으로 정의해주는 경우에는 컴파일러가 자동으로 생성해주지 않음
    의미있는 Data 클래스의 조건
        1. 기본생성자에 1개 이상의 파라미터가 있어야 함
            (= 기본생성자의 프로퍼티가 여러개)
        2. 기본생성자의 파라미터가 var, val로 선언
            (단순 변수는 안 되고 프로퍼티만 가능)
        3. Data 클래스는 abstract, open, sealed, inner가 안 됨
    Data 클래스 interface 구현 가능
    Sealed class 상속 가능

    기본값
        jvm에서 파라미터가 없는 생성자가 필요한 경우 모든 프로퍼티에 기본값을 설정해준다
        data class User(val name: String = "", val age: Int = 0)
        // name을 빈칸, age를 0으로 기본값을 설정해줌
        val exam_0 = User()
        val exam_1 = User("Kotlin")
        val exam_2 = User("Kotlin", 113)
        val exam_3 = User(age=113)
        val exam_4 = User(name="Kotlin", age=113)
```kotlin
fun main (args: Array<String>){
    val obj = User("Kotlin", 113) // 객체생성
    println(obj) //User(name=Kotlin, age=113) => 실제 데이터
    //decompile해서 보면 데이터 클래스 User에 equals, hashCode, copy, toString 함수가 쓰인걸 볼 수 있다

//    val obj2 = Nodata("Kotlin", 113)
//    println(obj2) //Nodata@133314b => 클래스타입+주소

    val obj3 = UserDefault()
    println(obj3.toString()) //UserDefault(name=Default, age=10)
    println(UserDefault("NewData")) //UserDefault(name=NewData, age=10)
    println(UserDefault(age = 111)) //UserDefault(name=Default, age=111)

    println(UserBody("test", 222)) //UserBody(name=test, age=222) => body에 있는 other는 출력되지 않음
    // 데이터 클래스의 body에 프로퍼티 선언은 가능하지만 컴파일러가 자동으로 만들어줬던 함수(equals 등)은 생성되지 않음
}

//data class User(name: String) // => 단순 변수 사용으로 에러(val/var 사용해야 함)
data class User(var name: String, var age: Int)
//class Nodata(var name: String, var age: Int)
data class UserDefault(var name: String = "Default", var age: Int = 10)
data class UserBody(var name: String, var age: Int){
    var other: Int = 1 // 바디에서 프로퍼티 생성
}
```
```kotlin
fun main (args: Array<String>) {
    val o = NoData("1", 1)
    val o1 = User("1", 1)
    println(o1)
    // 위에 breakpoint 설정하고 디버깅 하면 NoData는 값이 안 보이지만 데이터클래스인 User는 디버거에 값이 바로 보인다
    // o = {NoData@주소}
    // o1 = {User@주소} + ("User(name=1, age=1)"
    // => 데이터만 있는 클래스라면 데이터클래스로 선언해서 작성하는게 더 좋다
}

class NoData(var name: String, var age: Int)
data class User(var name: String, var age: Int)
```

    복사
        객체의 기존 값들은 유지하고 일부 값만 고쳐서 새로운 객체를 만들고 싶은 경우
        Data 클래스에 컴파일러가 copy를 만들어주기 때문에 바로 copy를 호출해서 사용하면 됨
        
        fun copy(name: String = this.name, age: Int = this.age) = User(name, age)
        val jack = User(name = "Jack", age = 1)
        val olderJack = jack.copy(age = 2)

    Destructuring Declarations
        data class는 Destructuring Declarations를 사용할 수 있다
        (컴파일러가 componentN 함수를 자동으로 만들어주기 때문)

        val jane = User("Jane", 35)
        val (name, age) = jane
            => destructuring을 이용해서 name에 Jane, age에 35를 받을 수 있다.
        println("$name, $age years of age") // "Jane, 35 years of age"
        
        fun main (args: Array<String>) {
            val o1 = User("1", 1)
            val name = o1.name
            val age = o1.age
            println(age)
            // 위 식을 destructuring을 이용하여 다음과 같이 간결하게 나타낼 수 있다.
            val(name, age) = User("Joon", 1)
            println("$name, $age")
        }
        data class User(var name: String, var age: Int)
    
    Standard Data Classes
        스탠다드 라이브러리에서 제공하는 데이터 클래스
            Pair, Triple

        이전엔 User라는 데이터클래스를 만들어서 사용했지만 값이 2개인 경우 Pair를 이용해서 똑같이 쓸 수 있다.
            val jane = User("Jane", 35)
            println(jane) // User(name=Jane, age=35)
            =
            val pair = Pair("Jane", 35)
            println(pair) // (Jane, 35)
        가독성을 위해서 프로퍼티에 의미있는 이름(User)을 제공하는 클래스를 사용하는 것이 더 좋음

        fun main (args: Array<String>){
            val obj = Pair("hahaha", 1)
            // Pair가 제네릭이어서 원래는 Pair<String, Int> 라고 표현하지만 괄호 안을 각각 String, Int으로 추론할 수 있어서 타입 생략가능
            println(obj)
        }

    Nested Classes (중첩 클래스)
        클래스는 다른 클래스에 중첩될 수 있음
            class Outer {
                private val bar: Int = 1

                class Nested {
                    fun foo() = 2
                }
            }
            val demo = Outer.Nested().foo() // 2
            // Outer 안의 클래스(Nested)의 객체를 생성하고 그 안의 함수를 부를 수 있음

            => Outer라는 클래스의 멤버로 Nested 클래스를 가지고 Nested 클래스는 멤버로 foo 함수를 갖는다

            한계) 내부 클래스(Nested)에서 외부 클래스(Outer)의 프로퍼티(bar)에 접근할 수 없음

    Inner Class (내부 클래스)
        클래스에 inner를 표기하면 바깥쪽 클래스의 멤버에 접근할 수 있음

        class Outer {
            private val bar: Int = 1
            inner class Inner {
                fun foo() = bar
            }
        }
        val demo = Outer().Inner().foo() // 1
        => 중첩클래스에서 호출하는 방법에다 Outer 클래스 객체 만드는 과정(Outer())이 추가됨

    Anonymous inner classes (익명 내부 클래스)
        객체 표현식(object expression)을 이용해서 익명 내부 클래스의 인스턴스를 생성할 수 있음
            mSearchEditText.setOnClickListener(object : View.OnClickListener {
                override fun onClick(v: View?){ ... }
            })

            => OnClickListener를 상속받은 object 클래스에서 onClick 함수를 재정의함
            => 객체표현식(setOnClickListener 옆의 ()괄호)의 결과는 onClick이 재정의된 object 클래스의 객체이다
            => 따라서 전체 구문이 하나의 객체를 생성하는 것과 같음
        
        Functional java interface인 경우에는 접두어에 인터페이스 이름을 사용해서 람다식("{}")으로 표현할 수도 있음
            mSearchEditText.setOnClickListener(View.OnClickListener {
                v -> ...
            })

            => Functional java interface == 함수가 하나인 클래스
            => 람다식{}이 위의 onClick 함수를 대체함

# Object Expression(표현) and Declarations(선언)
    object 용도
        어떤 class에서 조금 변경된 객체를 생성할 때
        새로운 subclass의 명시적인 선언 없이 바로 객체 생성

    Object Expressions
        Java 익명 객체
        (ex. onClickListener를 만들 때)
    
    Object Declarations(객체 선언)
        싱글턴을 만들고 처리할 때

    객체 표현식
        Java에서는 익명 내부 클래스를 사용해서 처리했음
            <Java 식>
            btn.setOnClickListener(new OnClickListener(){
                public void onClick(View v){

                }
            })
            => 익명 내부 클래스 OnClickListener(){ } 에서 onClick 구현
        
        위와 같은 표현을 하기 위해서 Kotlin에서는 object expressions를 이용

    객체 표현식 문법
        어떤 클래스를 상속받은 익명 객체를 생성
            window.addMouseListener(object : MouseAdapter(){
                override fun mouseClicked(e:MouseEvent){ }
                override fun mouseEntered(e:MouseEvent){ }
            })

            => window에 MouseListener 객체에서 mouseClicked, mouseEntered 를 구현하는 식.
            클래스를 만들지 않고 객체만 만들기 위해 object를 적고 MouserAdapter를 상속받아서 override로 두개의 메소드를 구현하고 큰 괄호() 안에 객체를 만들고 넘겨줌

    객체 표현식 상속
        슈퍼타입의 생성자가 있는 경우, 반드시 값을 전달해 주어야 함
        슈퍼타입이 여러개인 경우 ':' 뒤에 ',' 로 구분해서 명시해주면 됨

        open class A(x: Int){
            public open val y: Int = x
        }

        interface B { }

        val ab: A = object : A(1), B {
            override val y = 15
        }

```kotlin
    class MyRunnable : Runnable{
        override fun run() { // MyRunnable 에서 alt + enter로 run 메소드 구현
            println("hello kotlin")
        }
    }

    fun main (args: Array<String>){
        val t = Thread(MyRunnable())
        t.run()
    }

    위 식을 아래와 같이 object 키워드를 이용하여 표현 가능

    fun main (args: Array<String>){
        val t = Thread( object : Runnable{
            override fun run() { // MyRunnable 에서 alt + enter로 run 메소드 구현
                println("hello kotlin")
            }
        })
        t.run()
    }
    => object : 구현할 객체(슈퍼타입 리스트) {object에 대한 내용}

    그리고 다시 람다식으로 간단하게 표현 가능

    fun main (args: Array<String>){
    val t = Thread { println("hello kotlin") }
    t.run()
}
```

    객체 표현식 상속이 없는 경우
        특별히 상속받을 super types가 없는 경우, 간단하게 작성 가능
        val adHoc = object {
            var x: Int = 0
            var y: Int = 0
        }
        print(adHoc.x + adHoc.y)

```kotlin
    fun main (args: Array<String>){
        val data = object {
            var x = 1
            var y = 1
        }
        println("${data.x}, ${data.y}") // 1, 1
    }
    // object 뒤에 슈퍼타입 없음

    // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    fun main (args: Array<String>){
        val data = object { }
        println(data) // data 객체의 주소가 출력됨
    }
    // 이렇게 object와 비워져 있는 body만으로도 객체를 만들 수 있다.
```

    객체 표현식의 제약조건
        익명 객체가 local이나 private으로 선언될 때만 type으로 사용될 수 있음
        익명 객체가 public function이나 public property에서 리턴되는 경우, 익명객체의 슈퍼타입으로 동작됨. 이런 경우 익명 객체에 추가된 멤버에 접근이 불가능함.

        class C {
            private fun foo() = object { val x: String = "x"}
            fun publicFoo() = object { val x: String = "x"}

            fun bar() {
                val x1 = foo().x // 가능한 식
                val x2 = publicFoo().x // 오류
            }
        }
        => C 클래스에 객체표현식으로 객체를 생성함. 그리고 각 객체는 x값을 가짐. 하나는 private 함수, 다른 하나는 public 함수임. 해당 함수를 bar()함수에서 호출을 해보면 private인 foo()는 사용가능하지만 public인 publicFoo()는 사용 불가
```kotlin
    class MyClass {
        fun publicFun() = object {
            var x = 111
        }
        private fun privateFun() = object {
            var x = 222
        }
        fun print(){
            println(publicFun()) // 객체 주소 출력
            println(publicFun().x) // 사용불가
            println(privateFun()) // 객체 주소 출력
            println(privateFun().x) // x값 222 출력
        }
    }
    fun main (args: Array<String>){
        MyClass().print()
    }
    => private이든 public이든 각 객체에 접근까진 되지만 객체 body에 있는 변수는 불러올 수 없음
```
    
    객체 표현식의 특징
        익명 객체의 코드는 enclosing scope의 변수를 접근할 수 있음
        Java와는 다르게 final variables 제약 조건이 없음

        fun countClicks(window: JComponent){
            var clickCount = 0
            var enterCount = 0
            window.addMouserListener(object : MouseAdapter() {
                override fun mouseClicked(e: MouseEvent) {
                    clickCount++
                }
                override fun mouseEntered(e: MouseEvent) {
                    enterCount++
                }
            })
        }
        => MouseAdapter라는 익명 객체에서 해당 객체의 바깥에 있는 변수 clickCount와 enterCount에 접근 가능하다

    객체 선언
        객체 표현식과는 다름(객체를 표현하면 객체가 생성되지만 객체 선언은 객체를 생성하지 않고 선언만 하는 것)
        매우 유용한 Singleton 패턴을 kotlin에서는 object declarations을 이용해서 만들 수 있음

    객체 선언 문법
        - object 키워드 뒤에 항상 이름이 있어야 함
        - object declaration은 object expression이 아님
            object DataProviderManager{
                fun registerDataProvider(provider: DataProvider){
                    ...
                }
                val allDataProviders: Collection<DataProvider>
                    get() = ...
            }

        - 따라서 할당 구문의 우측에 사용될 수 없음 (객체 표현식과 다른점)
            fun main (args: Array<String>){
                val a = object CountManger {
                    var count = 0
                }
                println(CountManager)
            }
            => 오류발생
            => object를 오른쪽에 입력하면서 새로 a라는 변수에 담을 수 없다

        - object declaration의 객체를 참조하려면 해당 이름으로 직접 접근하면 됨
            => DataProviderManager.registerDataProvider(...)
            => 클래스였으면, 클래스의 생성자를 불러서 객체를 생성한 다음에 함수에 접근할 수 있었지만 객체 선언은 선언에 사용됐던 이름을 통해서 함수에 접근함

            object CountManager {
                var count = 0
            }

            fun main (args: Array<String>){
                CountManager.count++
                println(CountManager.count) // 1
                CountManager.count++
                println(CountManager.count) // 2
                CountManager.count++
                println(CountManager.count) // 3
            }

        - 슈퍼타입을 사질 수 있음(상속 가능)
        object DefaultListener : MouseAdapter() {
            override fun mouseClicked(e: MouseEvent){ }
            override fun mouseEntered(e: MouseEvent){ }
        }

# Companion Object
    Companion Object(동반자 객체)
        어떤 클래스에 관계된 싱글턴 object가 필요할 때 사용
        싱글턴 + Class method
            => static을 사용하면 될 것 같은데 사용하지 않는 이유
            : 일단 코틀린에는 static 변수 혹은 메소드가 없다. 대신 패키지 내에 함수를 선언하여 사용(Companion Object)할 수 있다.

    사용
        - 클래스 내부의 object declaration은 companion 키워드를 붙일 수 있음
            (companion만 빼면 객체선언과 같음)
            class MyClass{
                companion object Factory {
                    fun create(): MyClass = MyClass()
                }
            }

        - companion object의 멤버는 클래스 이름을 통해서 호출할 수 있음
            val instance = MyClass.create()
            => 객체 선언과 차이점) 객체선언은 Myclasss.Factory.create() 으로 접근함
    
        - companion object의 이름은 생략될 수 있음
            이런 경우 [class name].Companion 형태로 객체에 접근 가능
            class MyClass {
                companion object{

                }
            }
            val x = MyClass.Companion
        
        - companion object의 멤버가 Java의 static 멤버(함수)처럼 보일 수 있지만 다르다
        - companion object의 멤버는 실제 객체의 멤버임
        - 슈퍼클래스도 가질 수 있는 클래스의 객체임
            => companion object도 class의 객체이기 때문에 상속을 받을 수 있고 다른 여러 기능을 해낼 수 있다.

            interface Factory<T>{
                fun create() : T
            }
            class MyClass{
                companion object : Factory<MyClass>{
                    override fun create() : MyClass = MyClass()
                }
            }

# object expression VS object declaration
    object expression은 즉시 초기화되고 실행된다
        => 대입문 우측에 사용해서 객체를 바로 만들었음
    object declarations는 나중에 초기화된다(최초 접근시 초기화됨)
        => 싱글톤 대체
```kotlin
    object MyClass_1 {
        init{ println("create MyClass_1") }
    }
    object MyClass_2 {
        init{ println("create MyClass_2") }
    }
    object MyClass_3 {
        init{ println("create MyClass_3") }
    }
    fun main (args: Array<String>){
        println(1)
        println(MyClass_1) // 최초 접근시 객체 생성됨
        println(MyClass_1) // 여러번 호출해도 객체는 1개임
        println(2)
        println(MyClass_2) // 객체 생성
        println(3)
        println(MyClass_3) // 객체 생성
        println(4)
    }

    => println(1)에서 breakpoint를 만들고 디버깅한 뒤 한줄씩 진행하면서 Memory에서 My를 검색해보면 객체가 생성되었는지 안되었는지 확인할 수 있다.
    => 객체를 최초 호출시에만 생성되고 이후에 반복하여 호출하면 생성되지 않는걸 볼수 있다.
```
    companion object는 클래스가 로드될 때 초기화된다(Java의 static initializer와 비슷)

# 코루틴(Coroutine)
    - 코루틴은 이전에 자신의 실행이 마지막으로 중단되었던 지점 다음의 장소에서 실행을 재개한다
    - 안드로이드에서 비동기적으로 실행되는 코드를 단순화할 수 있는 concurrency(동시성) 디자인 패턴이다
    - 안드로이드에서 장시간 작업으로 인해서 생길 수 있는 기본 스레드의 차단이나 앱의 응답없음을 관리하는데 도움이 된다
    - 데이터베이스 또는 네트워크 액세스 같은 장시간 작업에 대한 비동기 콜백을 순차 코드로 변환하는 코틀린 기능이다
    - 일시 중단 기능을 사용하여 비동기 코드를 순차적으로 만든다

    예제 1)
    fun main() = runBlocking {
        val job = GlobalScope.launch {
            delay(1000L)
            println("World!")
        }

        println("Hello,")
        job.join() // 여기서 World! 가 출력되게 됨
    }

    => Hello,가 먼저 출력되고 이후에 World!가 출력된다
        코루틴을 통해 비동기가 적용되어서 GlobalScope.launch 안의 코드들이 실행되는 동안 println("Hello,")가 먼저 실행됨

        - launch는 코루틴의 빌더(builder)
        - GlobalScope는 빌더를 사용하기 위해 필요한 스코프(scope)
            global : 전역 스코프를 의미
        - job이란 변수에 GlobalScope의 결과를 저장한 뒤 join 함수를 이용해서 GlobalScope의 결과가 나오기까지 기다릴 수 있음
        - delay()함수를 통해 코루틴을 일정 시간 동안 멈추게 했다가 다시 실행시킬 수 있다

        단점 : 코루틴을 여러개 사용해야 할 경우 val job과 같이 코루틴 스코프마다 변수를 지정하고 실행 순서를 고려해서 join() 함수를 호출해야 하는 과정이 번거롭다. 따라서 다음 예제와 같이 부모 코루틴 안에 자식 코루틴을 만들어 관리한다.

    예제 2)
    fun main() = runBlocking {
        launch { // 이렇게 코루틴 빌더만 쓰면 runBlocking의 자식 코루틴임을 뜻함
            delay(1000L)
            println("World!")
        }
        println("Hello,")
    }

    => 부모 코루틴(runBlocking) 안에 자식 코루틴(launch)을 만들었다.
        만약 launch 안의 내용이 비대해져서 따로 관리를 하고 싶다면 다음 예제와 같이 suspend fun을 사용한다.

    예제 3)
    fun main() = runBlocking {
        launch {
            myWorld()
        }
        println("Hello,")
    }

    suspend fun myWorld(){
        delay(1000L)
        println("World!")
    }

    => 코루틴 안에서는 suspend fun만 사용할 수 있다.

    출처 : https://velog.io/@seung_min/AndroidKotlin-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%BD%94%EB%A3%A8%ED%8B%B4Coroutine
