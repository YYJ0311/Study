# 패키지 정의
    자바와 같이 파일 최상단에 적음
    자바와 다르게 디렉토리 상관없이 파일을 위치시켜도 됨
    (디렉토리와 패키지를 일치시키지 않아도 됨)

# 함수 정의
    함수는 fun 키워드로 정의
    fun sum(a: Int, b: Int): Int {
        return a + b
    }
    문법 
        fun 키워드 + 함수명 + (인자) + :리턴타입 { return }
    
    함수 몸체가 식인 경우 return 생략 가능, return type은 추론됨
    fun sum(a: Int, b: Int) = a + b
    => 맨 위와 같은 식임

# 함수 정의
    리턴할 값이 없는 경우 Unit(Object)로 리턴함
    Unit은 Java의 void와 같은 역할
    fun printKotlin(): Unit {
        println("hello Kotlin")
    }
    Unit은 생략 가능
    fun printKotlin() {
        println("hello Kotlin")
    }

# 지역 변수 정의
    val : 읽기전용 변수
        값의 할당이 1회만 가능, Java의 final과 유사
        val a: Int = 1 // 즉시 할당
        val b = 2 // 'Int' type 추론
        val c: Int // 컴파일 오류, 초기화가 필요함
        c = 3 // 컴파일 오류, 읽기전용
    var : Mutable 변수
        var x = 5
        x += 1

# 주석
    Java와 Javascript와 동일함
    // : 한줄 주석
    /* */ : 여러줄 주석, java와 다르게 주석 중첩 가능(주석 안에 주석)

# 문자열 템플릿
    String Interpolation (문자열 보간법)
    var a = 1
    val s1 = "a is $a"
    ($를 이용해서 변수이 직접 접근가능)

    a = 2
    val s2 = "${s1.replace("is","was")}, but now is $a"

# 조건문
    fun maxOf(a: Int, b: Int): Int {
        if(a>b){
            return a
        }else{
            return b
        }
    }

    축약 -> fun maxOf(a: Int, b: Int) = if(a>b) a else b

# nullable
    값이 null일 수 있는 경우 타입에 nullable 마크("?")를 명시해야 함
        fun parseInt(str: String): Int? {
            // 정수가 아닌 경우 null을 리턴
        }
        parseInt 안이 정수가 아닌 경우 null이 나올 수 있음 => ? 를 붙임으로써 null이 나올 수 있다는 것을 미리 알려준다.
        만약 ? 를 붙이지 않으면 컴파일 오류 발생함

    nullable 타입의 변수에 접근할 때는 반드시 null체크를 해야 함
        fun printProduct(arg1: String, arg2: String){
            val x: Int? = parseInt(arg1)
            val y: Int? = parseInt(arg2)

            if(x != null && y!= null){
                println(x*y)
            }else{
                println("either '$arg1' or '$arg2' is not a number")
            }
        }
        x와 y가 null일 수 있기 때문에 if로 체크한 뒤 x와 y에 접근한다. 만약 체크하지 않고 접근시 x나 y가 null이면 컴파일 오류가 발생하게 된다.

# 자동 타입 변환
    fun getStringLength(obj: Any): Int? {
        if (obj is String){
            // 'obj'가 자동으로 String 타입으로 변환됨
            return obj.length
        }
        return null
    }

    Any = Java의 Object 개념. 최상위 클래스
    위 식은 string 객체가 들어오는 경우에만 객체의 길이(length)를 반환한다.

# while loop
    Java와 같음

    val items = listOf("apple", "banana", "kiwi")
    var index = 0
    while (index < items.size){
        println("item at $index is ${items[index]}")
        index++
    }

    결과
        item at 0 is apple
        item at 1 is banana
        item at 2 is kiwi

# when expression
    Java의 switch case와 비슷해 보이지만 다르다
    (switch case는 정수나 스트링 정도만 지원되지만 코틀린에선 전부 가능)
    
    fun describe(obj: Any): String =
        when (obj) {
            1   -> "One"
            "Hello"    -> "Greeting"
            is Long    -> "Long"
            !is String  -> "Not a string"
            else    -> "Unknown"
        }
    
# ranges
    In 연산자를 이용해서 숫자 범위를 체크 가능
        val x = 3
        if (x in 1..10){ // x가 1에서 10 사이에 있다면
            println("fits in range")
        }
    
    range를 이용한 for loop
        for (x in 1..5){ // 1부터 5까지의 x에 대하여
            print(x) // 1 2 3 4 5
        }

# collections
    컬렉션도 in으로 loop 가능
        val items = listOf("apple", "banana", "kiwi")
        for(item in items){
            println(item)
        }

        listOf로 list를 생성하고 for문과 in을 사용하여 출력함
    
    In으로 해당 값이 collection에 포함되는지 체크 가능
        val items = setOf("apple", "banana", "kiwi")
        when{
            "orange" in items -> println("juicy")
            "apple" in items -> println("apple is fine too")
        }

        in으로 컬렉션에 포함된 값을 체크 가능
    
    람다식을 이용해서 컬렉션에 filter, map 등의 연산 가능
        val fruits = listOf("banana", "avocado", "apple", "kiwi")
        fruits
            .filter{ it.startsWith("a") } // a로 시작하는 것들만 필터링
            .sortedBy{ it } // it로 sorting
            .map{ it.uppercase() } // 대문자로 변경
            .forEach { println(it) } // 각각을 출력하라

        결과
            APPLE
            AVOCADO

        it은 list의 값들이 들어가는 변수

# 기본 타입
    코틀린에서 모든 것은 객체이다 <---> 자바는 primitive(기본형)와 reference 타입이 나눠져 있음
        자바의 Primitive(기본형) type
            기본값이 있기 때문에 Null이 존재하지 않음
            담을 수 있는 크기를 벗어나면 컴파일 에러 발생
            논리형(boolean), 정수형(byte, short, int, long), 실수형(float, double), 문자형(char)

        자바의 Reference(참조형) type
            기본형 타입을 제외한 타입들 모두를 지칭
            빈 객체를 의미하는 Null이 존재함
            배열(Array), 열거(Enumeration), 클래스(Class), 인터페이스(Interface)

    숫자(Number)
        kotlin에서 Number는 클래스이다(대문자로 사용함 Double, Float 등)
        Java에서 숫자형이던 char(Bit width : 16)가 kotlin에서는 숫자형이 아님
    
    리터럴(Literal)
        * Java에서 지원되던 8진수는 미지원 (Java: int I = 017; 앞이 0으로 시작하면 8진수로 해석되었음)
        10진수 : 123 (Int, Short)
        Long : 123L
        Double : 123.5 또는 123.5e10
        Float : 123.5f
        2진수 : 0b00001011 (0b로 시작)
        16진수 : 0X0F (0X로 시작)

        Underscores in numeric literals (코틀린 1.1 버전이후)
            긴 숫자의 경우 underscore(_)를 사용해서 구분하는 것도 언어에서 지원함
            val oneMillion = 1_000_000
            val creditCardNumber = 1234_5678_9012_3456L
            val socialSecurityNumber = 999_99_9999L
            val hexBytes = 0xFF_EC_DE_5E
            val bytes = 0b11010010_01101001_10010100_10010010

    Representation
        Kotlin 숫자형을 Java 플랫폼에서 사용하는 경우 JVM primitive type 또는 박싱이 돼서 object로 처리된다 (Nullable이나 제네릭의 경우에 박싱됨)
        박싱된 경우엔 identity를 유지하지 않는다
        
        // JVM primitive
        val a: Int = 100
        print(a === a) // true

        // Boxed
        val boxedA: Int? = a
        val anotherBoxedA: Int? = a
        println("==: ${boxedA == anotherBoxedA}") // true
        println("===: ${boxedA === anotherBoxedA}") // true

        tools > Kotlin > Show Kotlin Bytecode > 알아보고 싶은 것을 클릭하고 Decompile
        (코틀린을 컴파일하면 바이트코드가 됨. 이것을 Decompile 하면 자바코드를 얻을 수 있다.)
```kotlin
    fun main() {
        var a: Int = 100000
        var b: Int = 100000
        println("a === b: ${a === b}") // 같은 객체인지, true
        println("a == b: ${a == b}") // 값이 같은지, true

        /* decompile을 해보면 var a와 var b가 int a와 int b로 표시된다. (primitive 타입)
        처음에 var로 선언할 때 클래스(Int)로 선언했지만, 코틀린에서 JVM으로 돌아갈 땐 둘다 primitive 타입으로 사용되었다. */

        var c: Int? = 100000
        println("a === c: ${a === c}") // true
        println("a == c: ${a == c}") // true

        /* decompile 후 var c 는 Integer c 로 표시된다 (object 타입) */

        /* 강의에선 변수 c가 Nullable한 경우 object 타입으로 읽히고
        변수 a는 primitive 타입으로 읽혀서 === 으로 비교시 객체가 다르기 때문에 false를 반환한다고 나오는데.. 
        난 true가 나온다.. 왜지? */
    }
```
        어쨋든 Kotlin에서 숫자를 사용할 때 암묵적인 형변환을 지원하지 않는다 (더 작은 자료형은 더 큰 자료형에 서브 자료형이 아니다!)
        다시 정리하면, JVM 플랫폼에서 숫자는 int, double과 같은 primitive type으로 저장되고 nullable과 제네릭은 java class로 저장되므로 만약 암묵적 형변환이 있으면 객체 자체가 변화되는 일이 발생하고 equality와 identity 검사가 의미를 잃게 된다.
        따라서 kotlin에서는 암묵적 형변환은 지원되지 않고 명시적 형변환을 해줘야 한다.

        toInt() => .code
        toByte() => .code.toByte()
        toShort() => .code.toShort()
        toLong() => .code.toLong()
        toFloat() => .code.toFloat()
        toDouble() => .code.toDouble()
        toChar() 또는 .code.toChar()
        를 사용해서 형변환 함

        Explicit Conversions
            val a: Int = 1
            val b: Long = a // 오류 => Int를 Long으로 만들어주기 위해 형변환 필요
            val b: Long = a.toLong()
            
            println(a == b) // Int와 Long을 비교할 수 없기 때문에 오류 발생

            val i: Int = b.toInt()
            println(a == i) // true

    문자 (Characters)
        Char는 숫자로 취급되지 않음    
        
        fun check(c: Char){
            if(c == 1){ } // Char와 Int를 비교하기 때문에 컴파일 에러
        }

        fun check2(c: Char){
            if(c == 'a'){ } // 같은 문자형이기 때문에 컴파일 가능
        }

        fun main() {
            print('0'.code) // 문자 0을 숫자로 변환, 유니코드 값 48
        }
    
    문자열
        String 클래스로 표현
        String은 characters로 구성됨
        s[i]와 같은 방식으로 접근 가능 (immutable이므로 변경 불가)
        
        var x: String = "Kotlin"
        println(x.get(0)) // K
        println(x[0]) // K
        println(x.length) // 6

        for (c in x){
            println(c) // Kotlin
        }

        문자열 리터럴
            escaped string ("Kotlin")
                전통적인 방식으로 Java String과 거의 비슷
                Backslash(\)를 사용하여 escaping 처리
            
            raw string ("""kotlin""")
                큰따옴표 3개를 이용
                escaping 처리 필요 없음
                개행이나 어떠한 문자 포함 가능
            
            val s = "Hello, world!\n"
            val ss = """
            "'이것은 코틀린의
            raw String
            입니다.'"
            """

    배열
        Java와 생성 방법은 다르지만 사용방법은 비슷하다

        배열은 Array 클래스로 표현됨
        클래스 안에 get ,set 메소드 존재 
            []로 연산자 오버로딩해서 값에 접근함
        size 등 유용한 멤버함수 포함

        var array: Array<String> = arrayOf("코틀린", "강좌")
        println(array.get(0)) // 코틀린
        println(array[0]) // 코틀린
        println(array.size) // 2

        배열 생성
            Array의 팩토리 함수 이용
                val b = Array(5, { i => i.toString() })
                : i를 0부터 4까지 5개를 리턴하여 Array 생성

                fun main() {
                    val a = Array(5, { i -> i.toString() })
                    for (c in a) {
                        print(c) // 01234
                    }
                }
                
            arrayOf() 등의 라이브러리 함수 이용
                val a = arrayOf("0", "1", "2", "3", "4")

                fun main() {
                    val b = arrayOf("0", "1", "2", "3", "4", "5")
                    for (c in b) {
                        print(c) // 01234
                    }
                }

        특별한 Array 클래스
            Primitive 타입의 박싱 오버헤드를 없애기 위한 배열
                var array: Array<String> = arrayOf("코틀린", "강좌")
                에서 처럼 Array에 <String>을 붙이면 제네릭이 사용되고, 이 경우 primitive 타입이 아니라 reference 타입으로 동작하게 됨. 
                이런 것을 해결하기 위한 배열 => IntArray, ShortArray, IntArray 
            Array를 상속한 클래스들은 아니지만, Array와 같은 메소드와 프로퍼티를 가짐
            
            val x: IntArray = intArrayOf(1, 2, 3)
            x[0] = 7
            println(x.get(0)) // 7
            println(x[0]) // 7
            println(x.size) // 3
    
# 