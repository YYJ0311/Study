# 패키지 정의
    자바와 같이 파일 최상단에 적음
    자바와 다르게 디렉토리 상관없이 파일을 위치시켜도 됨
    (디렉토리와 패키지를 일치시키지 않아도 됨)

# 함수 정의
    함수는 fun 키워드로 정의
    fun sum(a: Int, b: Int): Int {
        return a + b
    }
    문법 
        fun 키워드 + 함수명 + (인자) + :리턴타입 { return }
    
    함수 몸체가 식인 경우 return 생략 가능, return type은 추론됨
    fun sum(a: Int, b: Int) = a + b
    => 맨 위와 같은 식임

# 함수 정의
    리턴할 값이 없는 경우 Unit(Object)로 리턴함
    Unit은 Java의 void와 같은 역할
    fun printKotlin(): Unit {
        println("hello Kotlin")
    }
    Unit은 생략 가능
    fun printKotlin() {
        println("hello Kotlin")
    }

# 지역 변수 정의
    val : 읽기전용 변수
        값의 할당이 1회만 가능, Java의 final과 유사
        val a: Int = 1 // 즉시 할당
        val b = 2 // 'Int' type 추론
        val c: Int // 컴파일 오류, 초기화가 필요함
        c = 3 // 컴파일 오류, 읽기전용
    var : Mutable 변수
        var x = 5
        x += 1

# 주석
    Java와 Javascript와 동일함
    // : 한줄 주석
    /* */ : 여러줄 주석, java와 다르게 주석 중첩 가능(주석 안에 주석)

# 문자열 템플릿
    String Interpolation (문자열 보간법)
    var a = 1
    val s1 = "a is $a"
    ($를 이용해서 변수이 직접 접근가능)

    a = 2
    val s2 = "${s1.replace("is","was")}, but now is $a"

# 조건문
    fun maxOf(a: Int, b: Int): Int {
        if(a>b){
            return a
        }else{
            return b
        }
    }

    축약 -> fun maxOf(a: Int, b: Int) = if(a>b) a else b

# nullable
    값이 null일 수 있는 경우 타입에 nullable 마크("?")를 명시해야 함
        fun parseInt(str: String): Int? {
            // 정수가 아닌 경우 null을 리턴
        }
        parseInt 안이 정수가 아닌 경우 null이 나올 수 있음 => ? 를 붙임으로써 null이 나올 수 있다는 것을 미리 알려준다.
        만약 ? 를 붙이지 않으면 컴파일 오류 발생함

    nullable 타입의 변수에 접근할 때는 반드시 null체크를 해야 함
        fun printProduct(arg1: String, arg2: String){
            val x: Int? = parseInt(arg1)
            val y: Int? = parseInt(arg2)

            if(x != null && y!= null){
                println(x*y)
            }else{
                println("either '$arg1' or '$arg2' is not a number")
            }
        }
        x와 y가 null일 수 있기 때문에 if로 체크한 뒤 x와 y에 접근한다. 만약 체크하지 않고 접근시 x나 y가 null이면 컴파일 오류가 발생하게 된다.

# 자동 타입 변환
    fun getStringLength(obj: Any): Int? {
        if (obj is String){
            // 'obj'가 자동으로 String 타입으로 변환됨
            return obj.length
        }
        return null
    }

    Any = Java의 Object 개념. 최상위 클래스
    위 식은 string 객체가 들어오는 경우에만 객체의 길이(length)를 반환한다.

# while loop
    Java와 같음

    val items = listOf("apple", "banana", "kiwi")
    var index = 0
    while (index < items.size){
        println("item at $index is ${items[index]}")
        index++
    }

    결과
        item at 0 is apple
        item at 1 is banana
        item at 2 is kiwi

# when expression
    Java의 switch case와 비슷해 보이지만 다르다
    (switch case는 정수나 스트링 정도만 지원되지만 코틀린에선 전부 가능)
    
    fun describe(obj: Any): String =
        when (obj) {
            1   -> "One"
            "Hello"    -> "Greeting"
            is Long    -> "Long"
            !is String  -> "Not a string"
            else    -> "Unknown"
        }
    
# ranges
    In 연산자를 이용해서 숫자 범위를 체크 가능
        val x = 3
        if (x in 1..10){ // x가 1에서 10 사이에 있다면
            println("fits in range")
        }
    
    range를 이용한 for loop
        for (x in 1..5){ // 1부터 5까지의 x에 대하여
            print(x) // 1 2 3 4 5
        }

# collections
    컬렉션도 in으로 loop 가능
        val items = listOf("apple", "banana", "kiwi")
        for(item in items){
            println(item)
        }

        listOf로 list를 생성하고 for문과 in을 사용하여 출력함
    
    In으로 해당 값이 collection에 포함되는지 체크 가능
        val items = setOf("apple", "banana", "kiwi")
        when{
            "orange" in items -> println("juicy")
            "apple" in items -> println("apple is fine too")
        }

        in으로 컬렉션에 포함된 값을 체크 가능
    
    람다식을 이용해서 컬렉션에 filter, map 등의 연산 가능
        val fruits = listOf("banana", "avocado", "apple", "kiwi")
        fruits
            .filter{ it.startsWith("a") } // a로 시작하는 것들만 필터링
            .sortedBy{ it } // it로 sorting
            .map{ it.uppercase() } // 대문자로 변경
            .forEach { println(it) } // 각각을 출력하라

        결과
            APPLE
            AVOCADO

        it은 list의 값들이 들어가는 변수
        