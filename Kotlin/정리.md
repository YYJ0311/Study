# 패키지 정의
    자바와 같이 파일 최상단에 적음
    자바와 다르게 디렉토리 상관없이 파일을 위치시켜도 됨
    (디렉토리와 패키지를 일치시키지 않아도 됨)

# 함수 정의
    함수는 fun 키워드로 정의
    fun sum(a: Int, b: Int): Int {
        return a + b
    }
    문법 
        fun 키워드 + 함수명 + (인자) + :리턴타입 { return }
    
    함수 몸체가 식인 경우 return 생략 가능, return type은 추론됨
    fun sum(a: Int, b: Int) = a + b
    => 맨 위와 같은 식임

# 함수 정의
    리턴할 값이 없는 경우 Unit(Object)로 리턴함
    Unit은 Java의 void와 같은 역할
    fun printKotlin(): Unit {
        println("hello Kotlin")
    }
    Unit은 생략 가능
    fun printKotlin() {
        println("hello Kotlin")
    }

# 지역 변수 정의
    val : 읽기전용 변수
        값의 할당이 1회만 가능, Java의 final과 유사
        val a: Int = 1 // 즉시 할당
        val b = 2 // 'Int' type 추론
        val c: Int // 컴파일 오류, 초기화가 필요함
        c = 3 // 컴파일 오류, 읽기전용
    var : Mutable 변수
        var x = 5
        x += 1

# 주석
    Java와 Javascript와 동일함
    // : 한줄 주석
    /* */ : 여러줄 주석, java와 다르게 주석 중첩 가능(주석 안에 주석)

# 문자열 템플릿
    String Interpolation (문자열 보간법)
    var a = 1
    val s1 = "a is $a"
    ($를 이용해서 변수이 직접 접근가능)

    a = 2
    val s2 = "${s1.replace("is","was")}, but now is $a"

# 조건문
    fun maxOf(a: Int, b: Int): Int {
        if(a>b){
            return a
        }else{
            return b
        }
    }

    축약 -> fun maxOf(a: Int, b: Int) = if(a>b) a else b

# nullable
    값이 null일 수 있는 경우 타입에 nullable 마크("?")를 명시해야 함
        fun parseInt(str: String): Int? {
            // 정수가 아닌 경우 null을 리턴
        }
        parseInt 안이 정수가 아닌 경우 null이 나올 수 있음 => ? 를 붙임으로써 null이 나올 수 있다는 것을 미리 알려준다.
        만약 ? 를 붙이지 않으면 컴파일 오류 발생함

    nullable 타입의 변수에 접근할 때는 반드시 null체크를 해야 함
        fun printProduct(arg1: String, arg2: String){
            val x: Int? = parseInt(arg1)
            val y: Int? = parseInt(arg2)

            if(x != null && y!= null){
                println(x*y)
            }else{
                println("either '$arg1' or '$arg2' is not a number")
            }
        }
        x와 y가 null일 수 있기 때문에 if로 체크한 뒤 x와 y에 접근한다. 만약 체크하지 않고 접근시 x나 y가 null이면 컴파일 오류가 발생하게 된다.

# 자동 타입 변환
    fun getStringLength(obj: Any): Int? {
        if (obj is String){
            // 'obj'가 자동으로 String 타입으로 변환됨
            return obj.length
        }
        return null
    }

    Any = Java의 Object 개념. 최상위 클래스
    위 식은 string 객체가 들어오는 경우에만 객체의 길이(length)를 반환한다.

# while loop
    Java와 같음

    val items = listOf("apple", "banana", "kiwi")
    var index = 0
    while (index < items.size){
        println("item at $index is ${items[index]}")
        index++
    }

    결과
        item at 0 is apple
        item at 1 is banana
        item at 2 is kiwi

# when expression
    Java의 switch case와 비슷해 보이지만 다르다
    (switch case는 정수나 스트링 정도만 지원되지만 코틀린에선 전부 가능)
    
    fun describe(obj: Any): String =
        when (obj) {
            1   -> "One"
            "Hello"    -> "Greeting"
            is Long    -> "Long"
            !is String  -> "Not a string"
            else    -> "Unknown"
        }
    
# ranges
    In 연산자를 이용해서 숫자 범위를 체크 가능
        val x = 3
        if (x in 1..10){ // x가 1에서 10 사이에 있다면
            println("fits in range")
        }
    
    range를 이용한 for loop
        for (x in 1..5){ // 1부터 5까지의 x에 대하여
            print(x) // 1 2 3 4 5
        }

# collections
    컬렉션도 in으로 loop 가능
        val items = listOf("apple", "banana", "kiwi")
        for(item in items){
            println(item)
        }

        listOf로 list를 생성하고 for문과 in을 사용하여 출력함
    
    In으로 해당 값이 collection에 포함되는지 체크 가능
        val items = setOf("apple", "banana", "kiwi")
        when{
            "orange" in items -> println("juicy")
            "apple" in items -> println("apple is fine too")
        }

        in으로 컬렉션에 포함된 값을 체크 가능
    
    람다식을 이용해서 컬렉션에 filter, map 등의 연산 가능
        val fruits = listOf("banana", "avocado", "apple", "kiwi")
        fruits
            .filter{ it.startsWith("a") } // a로 시작하는 것들만 필터링
            .sortedBy{ it } // it로 sorting
            .map{ it.uppercase() } // 대문자로 변경
            .forEach { println(it) } // 각각을 출력하라

        결과
            APPLE
            AVOCADO

        it은 list의 값들이 들어가는 변수

# 기본 타입
    코틀린에서 모든 것은 객체이다 <---> 자바는 primitive(기본형)와 reference 타입이 나눠져 있음
        자바의 Primitive(기본형) type
            기본값이 있기 때문에 Null이 존재하지 않음
            담을 수 있는 크기를 벗어나면 컴파일 에러 발생
            논리형(boolean), 정수형(byte, short, int, long), 실수형(float, double), 문자형(char)

        자바의 Reference(참조형) type
            기본형 타입을 제외한 타입들 모두를 지칭
            빈 객체를 의미하는 Null이 존재함
            배열(Array), 열거(Enumeration), 클래스(Class), 인터페이스(Interface)

    숫자(Number)
        kotlin에서 Number는 클래스이다(대문자로 사용함 Double, Float 등)
        Java에서 숫자형이던 char(Bit width : 16)가 kotlin에서는 숫자형이 아님
    
    리터럴(Literal)
        * Java에서 지원되던 8진수는 미지원 (Java: int I = 017; 앞이 0으로 시작하면 8진수로 해석되었음)
        10진수 : 123 (Int, Short)
        Long : 123L
        Double : 123.5 또는 123.5e10
        Float : 123.5f
        2진수 : 0b00001011 (0b로 시작)
        16진수 : 0X0F (0X로 시작)

        Underscores in numeric literals (코틀린 1.1 버전이후)
            긴 숫자의 경우 underscore(_)를 사용해서 구분하는 것도 언어에서 지원함
            val oneMillion = 1_000_000
            val creditCardNumber = 1234_5678_9012_3456L
            val socialSecurityNumber = 999_99_9999L
            val hexBytes = 0xFF_EC_DE_5E
            val bytes = 0b11010010_01101001_10010100_10010010

    Representation
        Kotlin 숫자형을 Java 플랫폼에서 사용하는 경우 JVM primitive type 또는 박싱이 돼서 object로 처리된다 (Nullable이나 제네릭의 경우에 박싱됨)
        박싱된 경우엔 identity를 유지하지 않는다
        
        // JVM primitive
        val a: Int = 100
        print(a === a) // true

        // Boxed
        val boxedA: Int? = a
        val anotherBoxedA: Int? = a
        println("==: ${boxedA == anotherBoxedA}") // true
        println("===: ${boxedA === anotherBoxedA}") // true

        tools > Kotlin > Show Kotlin Bytecode > 알아보고 싶은 것을 클릭하고 Decompile
        (코틀린을 컴파일하면 바이트코드가 됨. 이것을 Decompile 하면 자바코드를 얻을 수 있다.)
```kotlin
    fun main() {
        var a: Int = 100000
        var b: Int = 100000
        println("a === b: ${a === b}") // 같은 객체인지, true
        println("a == b: ${a == b}") // 값이 같은지, true

        /* decompile을 해보면 var a와 var b가 int a와 int b로 표시된다. (primitive 타입)
        처음에 var로 선언할 때 클래스(Int)로 선언했지만, 코틀린에서 JVM으로 돌아갈 땐 둘다 primitive 타입으로 사용되었다. */

        var c: Int? = 100000
        println("a === c: ${a === c}") // true
        println("a == c: ${a == c}") // true

        /* decompile 후 var c 는 Integer c 로 표시된다 (object 타입) */

        /* 강의에선 변수 c가 Nullable한 경우 object 타입으로 읽히고
        변수 a는 primitive 타입으로 읽혀서 === 으로 비교시 객체가 다르기 때문에 false를 반환한다고 나오는데.. 
        난 true가 나온다.. 왜지? */
    }
```
        어쨋든 Kotlin에서 숫자를 사용할 때 암묵적인 형변환을 지원하지 않는다 (더 작은 자료형은 더 큰 자료형에 서브 자료형이 아니다!)
        다시 정리하면, JVM 플랫폼에서 숫자는 int, double과 같은 primitive type으로 저장되고 nullable과 제네릭은 java class로 저장되므로 만약 암묵적 형변환이 있으면 객체 자체가 변화되는 일이 발생하고 equality와 identity 검사가 의미를 잃게 된다.
        따라서 kotlin에서는 암묵적 형변환은 지원되지 않고 명시적 형변환을 해줘야 한다.

        toInt() => .code
        toByte() => .code.toByte()
        toShort() => .code.toShort()
        toLong() => .code.toLong()
        toFloat() => .code.toFloat()
        toDouble() => .code.toDouble()
        toChar() 또는 .code.toChar()
        를 사용해서 형변환 함

        Explicit Conversions
            val a: Int = 1
            val b: Long = a // 오류 => Int를 Long으로 만들어주기 위해 형변환 필요
            val b: Long = a.toLong()
            
            println(a == b) // Int와 Long을 비교할 수 없기 때문에 오류 발생

            val i: Int = b.toInt()
            println(a == i) // true

    문자 (Characters)
        Char는 숫자로 취급되지 않음    
        
        fun check(c: Char){
            if(c == 1){ } // Char와 Int를 비교하기 때문에 컴파일 에러
        }

        fun check2(c: Char){
            if(c == 'a'){ } // 같은 문자형이기 때문에 컴파일 가능
        }

        fun main() {
            print('0'.code) // 문자 0을 숫자로 변환, 유니코드 값 48
        }
    
    문자열
        String 클래스로 표현
        String은 characters로 구성됨
        s[i]와 같은 방식으로 접근 가능 (immutable이므로 변경 불가)
        
        var x: String = "Kotlin"
        println(x.get(0)) // K
        println(x[0]) // K
        println(x.length) // 6

        for (c in x){
            println(c) // Kotlin
        }

        문자열 리터럴
            escaped string ("Kotlin")
                전통적인 방식으로 Java String과 거의 비슷
                Backslash(\)를 사용하여 escaping 처리
            
            raw string ("""kotlin""")
                큰따옴표 3개를 이용
                escaping 처리 필요 없음
                개행이나 어떠한 문자 포함 가능
            
            val s = "Hello, world!\n"
            val ss = """
            "'이것은 코틀린의
            raw String
            입니다.'"
            """

    배열
        Java와 생성 방법은 다르지만 사용방법은 비슷하다

        배열은 Array 클래스로 표현됨
        클래스 안에 get ,set 메소드 존재 
            []로 연산자 오버로딩해서 값에 접근함
        size 등 유용한 멤버함수 포함

        var array: Array<String> = arrayOf("코틀린", "강좌")
        println(array.get(0)) // 코틀린
        println(array[0]) // 코틀린
        println(array.size) // 2

        배열 생성
            Array의 팩토리 함수 이용
                val b = Array(5, { i => i.toString() })
                : i를 0부터 4까지 5개를 리턴하여 Array 생성

                fun main() {
                    val a = Array(5, { i -> i.toString() })
                    for (c in a) {
                        print(c) // 01234
                    }
                }
                
            arrayOf() 등의 라이브러리 함수 이용
                val a = arrayOf("0", "1", "2", "3", "4")

                fun main() {
                    val b = arrayOf("0", "1", "2", "3", "4", "5")
                    for (c in b) {
                        print(c) // 01234
                    }
                }

        특별한 Array 클래스
            Primitive 타입의 박싱 오버헤드를 없애기 위한 배열
                var array: Array<String> = arrayOf("코틀린", "강좌")
                에서 처럼 Array에 <String>을 붙이면 제네릭이 사용되고, 이 경우 primitive 타입이 아니라 reference 타입으로 동작하게 됨. 
                이런 것을 해결하기 위한 배열 => IntArray, ShortArray, IntArray 
            Array를 상속한 클래스들은 아니지만, Array와 같은 메소드와 프로퍼티를 가짐
            
            val x: IntArray = intArrayOf(1, 2, 3)
            x[0] = 7
            println(x.get(0)) // 7
            println(x[0]) // 7
            println(x.size) // 3
    
# Control Flow (흐름제어)
    If else 문
        Java와 유사함

        // Traditional usage
        var max = a
        if (a < b) max = b

        var max: Int
        if (a > b) {
            max = a
        } else {
            max = b
        }

        If 문이 식으로 사용되는 경우 (Java에 없음)
            val max = if (a > b) a else b
            If 식의 경우 반드시 else를 동반해야 한다
        
            If식의 branch들(If나 else)이 블럭({...})을 가질 수 있음
            블럭의 마지막 값이 해당 식의 값을 대표함
            val max = if (a > b){
                print("Choose a")
                a // if가 참일때 if 블럭에 있는 이 a 값이 max로 들어가게 됨
            } else {
                print("Choose b")
                b
            }
    
        삼항연산자(ternary)가 없다 (Java에 있지만 Kotlin엔 없음)
            코틀린에서 if문이 삼항연산자 역할을 잘 해낸다

            Java
            int max = (a > b) ? a : b; // 조건문이 참이면 a 거짓이면 b
            
            Kotlin
            val max = if(a > b) a else b
    
    when
        when문은 C열 언어의 switch문을 대체한다
        when문은 각각의 branches의 조건문이 만족할 때까지 위에서부터 순차적으로 인자를 비교한다        
            when (x) {
                1 -> print("x == 1")
                2 -> print("x == 2")
                else -> {
                    print("x is neither 1 nor 2")
                }
            }
            => 인자 x와 화살표 앞의 조건을 비교해서 해당되는 브랜치만 실행됨

            var res = when (x) {
                100 -> "A"
                90 -> "B"
                80 -> "C"
                else -> "F"
            }

        when이 식으로 사용된 경우 else문이 필수이다
        (컴파일러가 else문이 없어도 된다는 것을 입증할 수 있는 경우에는 else를 생략가능)
            var res = when (x) {
                true -> "맞다"
                false -> "틀리다"
            }
            => x에 boolean 으로 true/false 2가지만 오게 되는 경우에 else를 생략했다

        조건이 여러개라면 branch의 조건문에 콤마(,)를 사용한다
            when (x) {
                0, 1 -> print("x == 0 or x == 1")
                else -> print("otherwise")
            }
        
        branch의 조건문에 함수나 식을 사용할 수 있다
            when (x) {
                parseInt(x) -> print("s encodes x")
                1 + 3 -> print("4")
                else -> print("s does not encodes x")
            }

        range나 collection에 in이나 !in으로 범위 등을 검사할 수 있다
            val validNumbers = listOf(3, 6, 9)
            when (x) {
                in validNumbers -> print("x is valid") // x가 3, 6, 9 중에 있으면 프린트
                in 1..10 -> print("x is in the range") // 1부터 10 사이에 있으면 프린트
                !in 10..20 -> print("x is outside the range")
                else -> print("none of the above")
            }

        Is나 !is를 이용하여 타입을 검사할 수 있다
        이때 스마트 캐스트가 적용된다
        (스마트 캐스트 : 아래에서 x는 Any라고 선언했지만 Any에는 .startsWith() 가 없다. 하지만 앞에 x가 String일 경우라는 조건을 달아줬기 때문에 x를 String이라고 생각해서 해당 함수를 사용할 수 있게 되는 것)
            fun hasPrefix(x: Any) = when(x) {
                is String -> x.startsWith("prefix")
                else -> false
            }
            => x가 String이면 x.startsWith("prefix") 를 반환, 아니면 false 반환
            => Kotlin에서 타입 검사를 한 구문 뒤에서는 스마트캐스트가 적용된다

        if-else if 문을 대체할 수 있다
        when에 인자를 입력하지 않으면 조건문들이 논리연산됨
            when {
                x.isOdd() -> print("x is odd")
                x.isEven() -> print("x is even")
                else -> print("x is funny")
            }
            => if-else if로 길었던 구문을 when으로 한번에 처리할 수 있다!
    
    For Loops
        for문은 iterator를 제공하는 모든 것을 반복할 수 있다
            for (item in collection)
                print(item)
            => collection의 항목들이 item에 하나씩 들어오면서 프린트됨(foreach와 비슷)

            fun test(){
                var collection = listOf(1, 2, 3, 4, 5)
                for (item in collection) print(item) // 12345

                // iterator()와 while 사용
                var collectionIterator = collection.iterator()
                while (collectionIterator.hasNext()) {
                    print(collectionIterator.next()) // 12345
                }

                var array = arrayOf(1, 2, 3, 4, 5)
                for (i in array){
                    println("$i: $array[i]")
                }
            }
            => listOf와 arrayOf가 iterator를 반환하기 때문에 for문으로 사용할 수 있음
        
        for문의 body가 블럭이 올 수도 있음
        for (item in collection){
            print(item.id)
            print(item.name)
        }

        For문을 지원하는 iterator의 조건
            1) 멤버함수나 확장함수 중에 
                iterator()를 반환하고, next()를 가지고, hasNext(): Boolean을 가지는 경우
            2) 위 세 함수는 operator로 표기되어야 함

            fun main (args: Array<String>){
                val myData = MyData()
                for (item in myData){
                    print(item)
                }
            }
            // => MyData는 list나 array가 아닌데 for문안에 들어갔음 : myData가 iterator()를 반환하기 때문
            
            class MyData{
                operator fun iterator(): MyIterator{
                    return MyIterator()
                }
            }
            // => MyData 클래스에 operator 로 함수를 만들어서 Myiterator를 반환시켜줌

            class MyIterator{
                val data = listOf(1, 2, 3, 4, 5)
                var idx = 0
                operator fun hasNext(): Boolean {
                    return data.size > idx // idx가 5가 되면서 false를 리턴하면 종료된다
                }

                operator fun next(): Int {
                    return data[idx++]
                }
            }
            // => MyData에서 반환된 MyIterator는 list이고 operator로 된 hasNext()와 next()를 가진다
        => operator가 하나라도 빠지면 오류 발생
        => 어떤 객체가 iterator를 반환하면 next()와 hasNext(): Boolean를 구현하여 for문을 사용할 수 있다.

        배열이나 리스트에서 index를 이용하고 싶은 경우 indices 이용
            val array = arrayOf("가", "나", "다")
            for(i in array.indices){
                println("$i: ${array[i]}") // 0: 가 1: 나 2: 다
            }
        
        withIndex()로도 index 사용 가능
            val array = arrayOf("가", "나", "다")
            for ((index, value) in array.withIndex()){
                println("$index: ${value}") // 위와 같음
            }

    While Loops
        while, do-while문은 Java와 거의 같다
        Java와 다른점) do-while문에서 body의 지역변수를 do-while문의 조건문이 참조할 수 있음
            do {
                val y = retrieveData()
            } while (y != null)
            => Java의 경우 do 이전에 y를 선언하고 do와 while에서 각각 사용해야 했는데,
            코틀린은 do 안(do-while문의 body)에 y를 선언하고 while에서 사용할 수 있다.

# 패키지
    소스파일은 패키지 선언으로 시작됨
    모든 컨텐츠(클래스, 함수 등)는 패키지에 포함됨
    패키지를 명세하지 않으면 이름이 없는 기본 패키지에 포함됨

    Test.kt 파일에서 Other.kt와 Other2.kt 에 있는 두 함수를 불러오려고 함

    <Other.kt>
    // Other는 패키지를 적지 않아서 기본 패키지에 포함됨
    fun printOther1(){
        println("Other_1")
    }

    <Other2.kt>
    package test.pkg // Other2는 test.pkg에 있음을 표시함
    fun printOther2(){
        println("Other_2")
    }
    
    <Test.kt>
    import test.pkg.printOther2 
    // printOther2를 사용하기 위해 패키지 import함
    // import는 해당 함수를 클릭하고 Alt + 엔터
    fun main (){
        printOther1()
        printOther2()
    }

    => 명세한 패키지의 함수를 사용하기 위해선 import를 해야하고, 패키지를 명세하지 않았을 경우 그냥 함수를 바로 사용할 수 있다.

# 기본 패키지
    기본으로 import되는 패키지가 있음
    플랫폼 별로 import되는 패키지가 다르다

    kotlin.*
    kotlin.annotation.*
    kotlin.collections.*
    kotlin.comparisons.*
    kotlin.io.*
    kotlin.ranges.*
    kotlin.sequences.*
    kotlin.text.*

    JVM 추가 기본 패키지
        java.lang.*
        kotlin.jvm.*
    
    JS 추가 기본 패키지
        kotlin.js.*

    fun main(args: Array<String>) {
        var a = listOf(1, 2, 3)
        println(a)
    }
    => listOf() 함수는 Collections.kt 파일 안에 있고 해당 파일은 kotlin.collections 패키지에 포함되어 있기 때문에 import 없이 사용 가능하다

# Imports
    한개의 요소만 import
    import foo.Bar

    foo 패키지의 모든것을 import
    import foo.*

    같은 이름의 요소가 충돌되는 경우 as로 로컬 리네임 가능
    위에서 foo.Bar와 별개로 bar패키지의 Bar를 import하고 싶은 경우
    import bar.Bar as bBar

# Jump 표현식
    return, break, continue
    
    일반적으로 Java와 사용방법이 같음
        fun sum(a: Int, b: Int): Int{
            println("a: $a, b: $b")
            return a + b
        }

        for (x in 1..10) {
            if (x > 2){
                break
            }
            println("x: $x")
        }

        for (x in 1..10) {
            if (x < 3){
                continue
            }
            println("x: $x") // x: 3 ... x: 10
        }

    * 예외) Label로 Break and Continue
        레이블 표현 : label@, abc@, fooBar@
        (식별자 + @ 형태로 사용)

        loop@ for (i in 1..10) {
            println("--- i: $i ---")
            for (j in 1..10) {
                println("j: $j")
                if (i + j > 12){
                    break@loop
                }
            }
        }
        => for문 아래에서의 break는 해당 for문만 종료시킨다
        따라서 for문이 2개인 경우 둘다 종료시키기 위해서는 break를 2개 써야한다
        하지만 첫 for문을 loop@ 로 시작하고 다시 break@loop를 걸어주면 두 개의 for문을 한번에 종료시킬 수 있다

        loop@ for (i in 1..10) {
            println("--- i: $i ---")
            for (j in 1..10) {
                if (j < 2){
                    continue@loop
                }
                println("j: $j")
            }
        }
        => label이 j<2 일때 작동하므로 계속 첫 for문으로 돌려보낸다
        따라서 --- i: 1 --- 부터 --- i: 10 --- 까지 전부 출력됨

        * 예외) Label로 Return
            코틀린에서 중첩될 수 있는 요소들
                함수 리터럴(function literals)
                지역함수(local function)
                객체 표현식(object expression)
                함수(function)

            1. fun foo(){
                var ints = listOf(0, 1, 2, 3)
                ints.forEach(fun(value:Int){
                    if (value == 1) return // 1인 경우에 아래 프린트 함수 사용X
                    print(value)
                })
                print("End")
            }
            => forEach 안에 익명함수를 넣어서 사용함
                1일때 forEach에서 해당함수만 종료시킴(0, 2, 3에선 실행됨)
            => 출력 : 023End

            2. fun foo2(){
                var ints = listOf(0, 1, 2, 3)
                ints.forEach(
                    {
                        print(it)
                    }
                )
                print("End")
            }
            => 01234End

            3. fun foo2(){
                var ints = listOf(0, 1, 2, 3)
                ints.forEach(
                    { // 람다식(익명함수) 시작
                        if (it == 1) return
                        print(it)
                    }
                )
                print("End")
            }
            => 0
            => 1번과 결과가 다른 이유 : 람다식 안에서 return을 하면 가장 가까운 함수가 종료된다
            => 람다식만 종료시키고 싶을 경우, label로 return을 사용!

# 