# OBD (On Board Diagnostics)
    - MIL 이라고 하는 안내 등(Malfunction Indicator Lamp) 을 통해서 차량의 문제를 사용자나 정비사 에게 보여 주는 기능을 함
    - 운전자가 차량을 운행할 때, OBD 장치는 지속적으로 차량의 상태를 감시하게 됨
    - 94년 미국 전역에 배기가스에 대한 테스트 필요성이 대두되면서, 캘리포니아 대기 자원국이 OBD-II 명세서를 발표하고 96년 이후 생산 차량에 대해 적용하도록 규정함
    - OBD-II 크게 3가지 통신규격을 가짐
        1. VPW-PWM
        2. CAN 통신
        3. ISO 방식
        따라서 지금의 OBD-II 스캐너는 위 3가지 신호를 전부 지원함

# SSL(Secure Sockets Layer)
    보안 소켓 계층
    웹사이트와 브라우저 사이(또는 두 서버 사이)에 전송되는 데이터를 암호화하여 인터넷 연결을 보호하기 위한 표준 기술

    SSL 인증서
        인터넷 브라우저와 사이트의 웹서버 상의 암호화 통신을 지원하여 해킹을 당하더라도 고객의 개인정보를 지켜주는 역할. 로그인, 회원가입, 예약 등의 개인정보를 입력하더라도 스니핑으로부터 지켜준다.

        웹서버와 웹사이트에서 이루어지는 모든 정보전송을 https 암호화프로토콜을 통해 안전하게 전송되도록 하는 인증서
    
    SSL 인증서 적용 절차(comodo 기준)
        1. ssl 인증서 구매
        2. csr처리(개인 키를 만들어서 인증기관에 줘야 함)
        3. 인증기관에서 확인 뒤 인증서를 받음
        4. 웹 서버에 인증서 설치

    웹 서버에 설치 방법(apache 기준)
        1. 인증서 및 키 파일이 저장된 디렉토리에 인증서를 폴더로 업로드함
            보안을 위해 파일을 루트에서만 읽을 수 있도록 함
        2. 텍스트 편집기로 파일을 열어서 복사하고, apache 구성 파일에서 < VirtualHost > 블럭 아래에 붙여넣기

    참고 : https://kr.godaddy.com/help/manually-install-an-ssl-certificate-on-my-apache-server-ubuntu-32078

# CSR(Certificate Signing Request)
    인증기관에 인증서 발급 요청을 하는 특별한 ASN.1 형식의 파일로 이루어져있다.
    내 공개키 정보와 사용하는 알고리즘 정보등이 들어있다.
    개인키는 외부에 유출되면 안되므로 이런 특별한 형식의 파일을 만들어서 인증기관에 전달하여 인증서를 발급받는다.
    ASN.1 안에 내용에는 국가코드, 도시, 회사명, 부서명, 이메일, 도메인주소 등을 기록해야 한다. 

# Apache와 Tomcat
    Apache : 웹서버 프로그램
        웹서버
            하드웨어 
                : 웹 서버 소프트웨어와 웹 사이트의 구성 용소 파일을 저장하는 컴퓨터
            소프트웨어 
                : HTTP 서버 (URL 및 HTTP를 이해하는 소프트웨어. 도메인 이름을 통해 액세스 할 수 있으며 사용자의 장치로 전달한다.)
        아파치 서버
            클라이언트에서 요청하는 HTTP 요청을 처리하는 웹서버
            정적타입(HTML, CSS, 이미지 등)의 데이터만 처리하기 때문에 톰캣이 등장했다.
    
    Tomcat WAS(web application server): 컨테이너, 웹 컨테이너, 서블릿 컨테이너
        JAVA EE 기반으로 만들어졌으며, JSP와 Servlet을 구동하기 위한 서블릿 컨테이너 역할을 수행한다.
        아파치 서버와는 다르게 DB연결, 다른 응용프로그램과 상호작용 등 동적인 기능들을 사용할 수 있다.

        컨테이너
            : 동적인 데이터들을 가공하여 정적인 파일로 만들어주는 모듈
        서블릿
            : 클라이언트의 요청을 받고 요청을 처리하여 결과를 클라이언트에게 제공하는 자바 인터페이스
        서블릿 컨테이너
            : 서블릿들을 관리함. 새로운 요청이 들어올 때마다 새로운 스레드를 생성.
        WAS (web application server)
            : DB 처리, 로직 처리를 요구하는 동적타입을 제공하는 소프트웨어 프레임워크
    
    apche tomcat으로 부르는 이유?
        톰캣 안에 있는 컨테이너를 통해 일부 아파치의 기능을 발휘하기 때문

# Apache와 tomcat 상관관계
    apache는 웹서버(WS)
    tomcat은 웹 어플리케이션 서버(WAS)

    웹서버(Web Server)
        웹 클라이언트로부터 http 요청을 받아서 컨텐츠를 제공하는 프로그램

        정적인 컨텐츠 제공
            WAS를 거치지 않고 바로 클라이언트로 자원을 제공한다.
        동적인 컨텐츠 제공
            클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(Response)한다.
        ex ) Apache, Nginx

    웹 어플리케이션 서버(Web Application Server)
        동적인 컨텐츠를 제공하기 위해 만들어진 Application Server
        클라이언트의 http요청을 받아 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어
        내부적인 구조로 웹 서버와 웹 컨테이너가 들어있다.
            1) Web Container
                자바일 경우 JSP, Serverlet Class 파일을 실행하기 위한 실행 환경을 제공하는 역할. 주로 DB와 함께 실행된다.
            2) Web Server
                웹 서버가 WAS안에도 존재한다. 역시 URL 주소의 해석을 맡아 컨텐츠를 넘겨주고, 요청된 URL이 Servlet Class 또는 JSP 파일의 경우 Web Container가 처리하도록 요청을 넘긴다. 처리 후에 그 결과를 다시 받아 클라이언트에게 제공 한다.
        ex ) Tomcat, JBoss, Jeus, Web Sphere 등

    클라이언트와 WAS를 한 번에 연결하면 되는데도 굳이 WS를 거치는 이유
        1) 기능을 분리하여 서버 부하 방지
        2) 물리적으로 분리하여 보안 강화
        3) 여러 대의 WAS를 연결 가능
        4) 여러 웹 어플리케이션 서비스 가능(php와 java를 함께 사용)

# API 서버
    API = Application Programming Interface
        API의 의미는 도메인마다 뜻이 다르게 해석될 수 있어서 정확한 개념은 아니지만, "두 관계 간에 데이터를 주고받을 수 있도록 고안된 인터페이스" 라고 생각하면 됨
    API 서버는 이런 API를 제공해주는 서버이다.
    API 서버가 필요한 이유
        1. 변경된 정보가 즉시 다른 이용자에게도 업데이트되어야 할 때, 한 클라이언트가 다른 모든 클라이언트와 통신하는 것보다 하나의 서버가 다른 클라이언트에게 정보를 전달해주기가 쉽다.
        2. 공간적 한계가 있다. 수많은 데이터를 클라이언트마다 저장하는 것은 낭비이다.
        3. 나에게 권한이 있지 않은 데이터까지 모두 클라이언트에 보관하는 것은 보안 문제가 있다.
    위의 이유들로 데이터를 클라이언트로부터 분리해서 서버에 저장할 수밖에 없다.
    클라이언트는 정보에 접근하고 정보를 수정하기 위해 서버에 지속적으로 요청을 보내야 하고, 이 요청을 보내는 방법을 약속해둔 것이 API이다.

# Fast API
    파이썬 웹 프레임워크 중 가장 빠른 속도를 지닌 프레임워크
    nodejs나 go와 대등할 정도로 매우 높은 성능
    starlette을 이용하여 C를 위협할 정도로 빠른 속도를 가짐

    starlette
        다른 파이썬 웹 프레임워크(WSGI방식)인 Django나 Flask보다 가볍고 강력한 ASGI프레임워크.
    
    ASGI
        기존의 웹 스크립트나 애플리케이션이 웹 서버와 통신하는 방식이던 WSGI(동기 함수 처리 방식)보다 더 빠르게 비동기 처리 방식을 통해서 많은 트래픽을 처리할 수 있으며 더욱 빠른 처리가 가능하다

# FTP
    파일 전송 프로토콜(File Transfer Protocol)

    FTP는 비밀번호가 평문으로 전송되어 보안성이 매우 떨어지므로 FTPS를 사용해야 한다.
    
    데이터를 주고받기 위해서는 FTP 서버와 FTP 클라이언트가 필요하다.

    웹 브라우저도 FTP를 지원한다. 주소창에서 http:// 대신 ftp:// 를 붙이고 FTP 서버 주소를 치면 ID와 비밀번호를 묻는 화면이 뜨고, 그걸 치고 들어갈 수 있다. 단 리스트 보기와 다운로드만 가능하며 업로드는 지원하지 않는다.

    ex ) FileZilla, WinSCP, Termius, SmartFTP, 윈도우 탐색기 등

    VSCode에서 ftp 설정방법
        extension으로 ftp-simple 설치
        f1 단축키로 ftp-simple : Config - FTP connection setting 입력
        설정창에서 설정
            name : ftp 서버의 이름을 지정합니다. (사용자 구분을 위해 작성합니다)
            host : 서버의 도메인 또는 아이피주소를 입력합니다.
            port : 접속 포트
            username : 계정 아이디
            password : 비밀번호
            path : 접속 폴더 경로
            autosave : 서버 파일을 자동 저장 할지 여부
            confirm : 서버에 저장할것 지 확인 (true = 저장, false = 확인 없이 저장)
        저장 후 f1 단축키로 ftp-simple : Remote directory open to workspace 입력
        수정할 서버의 이름 클릭
        current directory를 클릭해서 서버 전체의 디렉토리 수정 가능
        서버의 폴더가 불러와 짐

# ERD (Entity Relationship Diagram)
    개체 - 관계 모델
    테이블 간의 관계를 설명해주는 다이어그램
    ERD를 통해 프로젝트에 사용되는 DB의 구조를 한 눈에 파악할 수 있다
    즉, API를 효율적으로 뽑아내기 위한 모델 구조도이다
    
    직사각형 같은 형태와 연결선 같은 정해진 기호 집합을 사용해서 Entity, Relationships 및 해당 속성의 상호 연결성을 나타낸다.

# JWT(JSON Web Token) / JWS / JWE
    API 인증 등에 사용하는 토큰
    RFC 7519 웹 표준으로 지정이 되어있으며 Json 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token.
    클라이언트와 서버, 서비스와 서비스 사이 통신 시 권한 인가를 위해 사용하는 토큰.
    URL에 대해 안전한 문자열로 구성되어 있기 때문에 HTTP 어디든 위치할 수 있다.

    일반적인 토큰 기반의 인증
        1. API 요청시 헤더나 파라미터에 엑세스토큰을 가져오도록 하고 이 토큰을 보고 유효한지 확인함으로써 인증한다 (서비스에 따라서 앱 ID나 비밀키를 같이 사용하기도 함)
        2. 보통은 DB에 토큰을 저장한다. 만료시간이나 토큰의 사용자 등을 저장해 놓고 유효한 토큰인지 검사하고 유효한 경우 해당 사용자라고 인식한 뒤, 사용자의 권한으로 사용할 수 있는 정보를 조회하게 된다. 요청마다 DB를 조회하는 것은 비용이 꽤 크므로 캐시서버를 둬서 성능을 높이기도 한다.
    
    JWT 특징
        다른 토큰하고 다른 점 : 토큰 자체가 데이터를 가지고 있다.

        토큰을 받아서 서명으로 유효한 토큰인지 검증한 뒤 유효하다면, 클레임셋을 디코딩해서 토큰에 담긴 데이터를 열어본다.
        
        클레임셋의 JSON에 만료시간 등이 담겨있으므로 토큰이 사용가능한지 검사를 하고 이상이 없으면 바로 사용한다.

        토큰의 사용자 아이디 등이 클레임셋에 담겨있다면 DB나 캐시를 조회할 필요 없이 바로 애플리케이션에서 사용자를 확인하고 정보를 조회할 수 있다. 대신 다른 토큰보다 길이가 좀 길다.

    구조
        .으로 연결된 Header.Payload.Signature 의 형태

        HEADER
            토큰 타입과, 해시 암호화 알고리즘 정보 2가지를 담고 있음
            Map<String, Object>타입으로 typ(토큰 타입), alg(알고리즘)이 포함되어야 함
            알고리즘은 보통 HMAC SHA256 혹은 RSA 가 사용되며, 시그니처를 해싱하기 위해 토큰을 검증 할 때 사용되는 signature 부분에서 사용된다.
        PAYLOAD
            Map<String, Object>타입으로 Claim(토큰 발급대상, 토큰 만료기간, 토큰 수령자 등)을 담고 있다.

            Claim은 3가지 타입이 존재
                Reserved Claims
                    정보 교환에 유용하도록 미리 정의되어 있는 클레임
                    이 클레임은 필수적이지 않고 Optional이다.

                Public Claims
                    충돌이 방지된 네임스페이스를 담고있는 URI와 같이 이름이 충돌되지 않도록 해야함

                Private Claims
                    서버와 클라이언트가 정보를 공유하기 위해 사용하기로한 클레임 정보 
        SIGNATURE
            서명은 토큰이 변조되지 않았음을 증명하는 무결성을 위해 사용
            시그니쳐는 인코딩된 헤더, 페이로드, 비밀키, 헤더에 정의된 서명 알고리즘을 이용하여 생성함

            Jwts.builder()의 signWith(알고리즘, key의 byte) 메소드 이용
            시크릿 키를 포함하여 암호화 되어있다

        * jwt는 payload에 데이터 내용을 담아 json으로 보내고, 이 json은 매우 쉽게 인코딩하고 디코딩될 수 있다. 따라서 payload에 유저 비밀번호와 같은 중요한 정보를 담으면 안 된다!

    장점
        중앙의 인증서버, 데이터 스토어에 대한 의존성이 없다.
        시스템 수평 확장에 유리하다
        Base64 URL Safe Encoding > URL, Cookie, Header 모두 사용이 가능하다.
    단점
        Payload의 정보가 많아지면 네트워크 사용량 증가, 데이터 설계 고려가 필요하다.
        토큰이 클라이언트에 저장, 서버에서 클라이언트의 토큰을 조작할 수 없다.
        
    문제점
        1. 클레임셋은 암호화하지 않으므로 서명 없이 누구나 열어볼 수 있기 때문에 보안이 중요한 데이터는 넣으면 안 된다.
        2. 내용이 많아질수록 토큰의 길이도 길어진다.
        3. 토큰을 강제로 만료시킬 방법이 없다. 로그인 상태에서 누군가 토큰을 탈취한다면 해당 토큰의 만료시간까지 유효하게 된다.

    - Base64
        8비트 이진 데이터를 문자코드에 영향을 받지 않는 일련의 문자열로 바꾸는 인코딩 방식
        예를들어 Man이라는 단어를 Base64로 인코딩하면 TWFu가 됨
    
    JWS (Json Web Signature)
        서버에서 한 인증을 근거로 인증정보를 서버의 private key로 서명 한것을 토큰화 한것
        header(json) + payload(json) + signature 구조의 JWT에서 시그니쳐는 토큰의 유효성을 검증하기 위한 문자열로 구성되어 있음

    JWE (Json Web Encryption)
        서버와 클라이언트 간 암호화된 데이터를 토큰화 한 것

# MIME(Multipurpose Internet Mail Extension)
    이메일과 함께 동봉할 파일을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발됨
    지금은 웹을 통해서 여러 형태의 파일을 전달하는데 쓰이고 있다.

    인코딩
        MIME을 사용하기 전에는 UUEncode 방식을 이용하고 있었는데, 이 방식에는 ASCII파일이 아닌 바이너리 파일(음악, 영화, 워드 등)을 보낼 수 없다는 단점이 있었고, 이를 보완해서 바이너리 파일을 전달할 수 있게끔 나온게 MIME이다.
        MIME은 바이너리 파일을 텍스트파일로 변환(인코딩)하여 보내준다.
    
    데이터 처리 과정
        MIME으로 인코딩한 파일은 Content-type 정보를 파일의 앞부분에 담는다.
        웹브라우저에서 서버에 접속하여 html 문서를 요청하는 경우, 문서의 이미지 파일이 브라우저에서 지원하는 MIME Type인 경우 웹을 통해 볼 수 있다.
    
    MIME 형식
        파일 종류(image)/파일 포맷(gif) 의 형태
        * MIME은 공백, 대/소문자 구분하지 않으며 대부분 소문자로 쓰인다
    
    MIME Type
        text
        multipart
            : 모든 이미지를 나타내지만, 비디오는 포함되지 않음
        audio
        video
        application
            : 모든 이진 데이터(바이너리 데이터)를 전송

# 클러스터링(Clustering)
    똑같은 구성의 서버 여러대를 병렬로 연결한 상태
    여러대의 서버 컴퓨터를 마치 하나의 가상 컴퓨터처럼 업무를 수행하도록 하는 것을 의미

    클러스터링된 서버들 중에서 특정 한대의 서버에서 장비적인 문제나 어플리케이션에 문제가 발생하더라도 로드발란서(Load Balancer)에서 그 서버의 분배를 제거함으로 전체적인 서비스에는 영향을 주지 않고 제어할 수 있으며, 정상적인 서비스가 지속적으로 이루어지게 할 수 있다.

    세션 클러스터링
        WAS가 2대 이상 연결되어 있을 경우 연결된 모든 서버의 세션을 동일한 세션으로 관리할 수 있도록 해주는 것
        
        하나의 WAS에서 허용된 동접수를 초과한 접속이 발생할 경우 다른쪽으로 접속을 유도 시켜줄 수 있다.
        이런 경우 기존 WAS의 세션이 아닌 새로 접속된 WAS로 세션이 이루어지고 기본적으로는 세션 불이치가 발생함
        그래서 세션 클러스터링을 이용하여 각 WAS에 대한 세선을 하나의 세션으로 관리하게 함으로써 새로운 WAS로 접속하더라도 세션은 하나로 관리되기 때문에 세션에 대한 불일치 발생을 없앨 수 있다.
        